/*
 Input Mask plugin for jquery
 http://github.com/RobinHerbots/jquery.inputmask
 Copyright (c) 2010 - 2013 Robin Herbots
 Licensed under the MIT license (http://www.opensource.org/licenses/mit-license.php)
 Version: 4.0.9
*/

! function(i) {
    var n = {};

    function a(e) {
        if (n[e]) return n[e].exports;
        var t = n[e] = {
            i: e,
            l: !1,
            exports: {}
        };
        return i[e].call(t.exports, t, t.exports, a), t.l = !0, t.exports
    }
    a.m = i, a.c = n, a.d = function(e, t, i) {
        a.o(e, t) || Object.defineProperty(e, t, {
            enumerable: !0,
            get: i
        })
    }, a.r = function(e) {
        "undefined" != typeof Symbol && Symbol.toStringTag && Object.defineProperty(e, Symbol.toStringTag, {
            value: "Module"
        }), Object.defineProperty(e, "__esModule", {
            value: !0
        })
    }, a.t = function(t, e) {
        if (1 & e && (t = a(t)), 8 & e) return t;
        if (4 & e && "object" == typeof t && t && t.__esModule) return t;
        var i = Object.create(null);
        if (a.r(i), Object.defineProperty(i, "default", {
                enumerable: !0,
                value: t
            }), 2 & e && "string" != typeof t)
            for (var n in t) a.d(i, n, function(e) {
                return t[e]
            }.bind(null, n));
        return i
    }, a.n = function(e) {
        var t = e && e.__esModule ? function() {
            return e.default
        } : function() {
            return e
        };
        return a.d(t, "a", t), t
    }, a.o = function(e, t) {
        return Object.prototype.hasOwnProperty.call(e, t)
    }, a.p = "", a(a.s = 0)
}([function(e, t, i) {
    "use strict";
    i(1), i(6), i(7);
    var n = o(i(2)),
        a = o(i(3)),
        r = o(i(4));

    function o(e) {
        return e && e.__esModule ? e : {
            default: e
        }
    }
    a.default === r.default && i(8), window.Inputmask = n.default
}, function(e, t, i) {
    "use strict";
    var n, a, r;
    a = [i(2)], void 0 === (r = "function" == typeof(n = function(e) {
        return e.extendDefinitions({
            A: {
                validator: "[A-Za-zА-яЁёÀ-ÿµ]",
                casing: "upper"
            },
            "&": {
                validator: "[0-9A-Za-zА-яЁёÀ-ÿµ]",
                casing: "upper"
            },
            "#": {
                validator: "[0-9A-Fa-f]",
                casing: "upper"
            }
        }), e.extendAliases({
            cssunit: {
                regex: "[+-]?[0-9]+\\.?([0-9]+)?(px|em|rem|ex|%|in|cm|mm|pt|pc)"
            },
            url: {
                regex: "(https?|ftp)//.*",
                autoUnmask: !1
            },
            ip: {
                mask: "i[i[i]].i[i[i]].i[i[i]].i[i[i]]",
                definitions: {
                    i: {
                        validator: function(e, t, i) {
                            return e = -1 < i - 1 && "." !== t.buffer[i - 1] ? (e = t.buffer[i - 1] + e, -1 < i - 2 && "." !== t.buffer[i - 2] ? t.buffer[i - 2] + e : "0" + e) : "00" + e, new RegExp("25[0-5]|2[0-4][0-9]|[01][0-9][0-9]").test(e)
                        }
                    }
                },
                onUnMask: function(e) {
                    return e
                },
                inputmode: "numeric"
            },
            email: {
                mask: "*{1,64}[.*{1,64}][.*{1,64}][.*{1,63}]@-{1,63}.-{1,63}[.-{1,63}][.-{1,63}]",
                greedy: !1,
                casing: "lower",
                onBeforePaste: function(e) {
                    return (e = e.toLowerCase()).replace("mailto:", "")
                },
                definitions: {
                    "*": {
                        validator: "[0-9１-９A-Za-zА-яЁёÀ-ÿµ!#$%&'*+/=?^_`{|}~-]"
                    },
                    "-": {
                        validator: "[0-9A-Za-z-]"
                    }
                },
                onUnMask: function(e) {
                    return e
                },
                inputmode: "email"
            },
            mac: {
                mask: "##:##:##:##:##:##"
            },
            vin: {
                mask: "V{13}9{4}",
                definitions: {
                    V: {
                        validator: "[A-HJ-NPR-Za-hj-npr-z\\d]",
                        casing: "upper"
                    }
                },
                clearIncomplete: !0,
                autoUnmask: !0
            }
        }), e
    }) ? n.apply(t, a) : n) || (e.exports = r)
}, function(e, t, i) {
    "use strict";
    var n, a, r, ge = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(e) {
        return typeof e
    } : function(e) {
        return e && "function" == typeof Symbol && e.constructor === Symbol && e !== Symbol.prototype ? "symbol" : typeof e
    };
    a = [i(3), i(5)], void 0 === (r = "function" == typeof(n = function(re, oe, se) {
        var le = oe.document,
            e = navigator.userAgent,
            ue = e.indexOf("MSIE ") > 0 || e.indexOf("Trident/") > 0,
            fe = me("touchstart"),
            ce = /iemobile/i.test(e),
            pe = /iphone/i.test(e) && !ce;

        function de(e, t, i) {
            if (!(this instanceof de)) {
                return new de(e, t, i)
            }
            this.el = se;
            this.events = {};
            this.maskset = se;
            this.refreshValue = false;
            if (i !== true) {
                if (re.isPlainObject(e)) {
                    t = e
                } else {
                    t = t || {};
                    if (e) t.alias = e
                }
                this.opts = re.extend(true, {}, this.defaults, t);
                this.noMasksCache = t && t.definitions !== se;
                this.userOptions = t || {};
                this.isRTL = this.opts.numericInput;
                f(this.opts.alias, t, this.opts)
            }
        }

        function f(e, t, i) {
            var n = de.prototype.aliases[e];
            if (n) {
                if (n.alias) f(n.alias, se, i);
                re.extend(true, i, n);
                re.extend(true, i, t);
                return true
            } else if (i.mask === null) {
                i.mask = e
            }
            return false
        }

        function r(i, s) {
            function e(e, t, i) {
                var n = false;
                if (e === null || e === "") {
                    n = i.regex !== null;
                    if (n) {
                        e = i.regex;
                        e = e.replace(/^(\^)(.*)(\$)$/, "$2")
                    } else {
                        n = true;
                        e = ".*"
                    }
                }
                if (e.length === 1 && i.greedy === false && i.repeat !== 0) {
                    i.placeholder = ""
                }
                if (i.repeat > 0 || i.repeat === "*" || i.repeat === "+") {
                    var a = i.repeat === "*" ? 0 : i.repeat === "+" ? 1 : i.repeat;
                    e = i.groupmarker[0] + e + i.groupmarker[1] + i.quantifiermarker[0] + a + "," + i.repeat + i.quantifiermarker[1]
                }
                var r, o = n ? "regex_" + i.regex : i.numericInput ? e.split("").reverse().join("") : e;
                if (de.prototype.masksCache[o] === se || s === true) {
                    r = {
                        mask: e,
                        maskToken: de.prototype.analyseMask(e, n, i),
                        validPositions: {},
                        _buffer: se,
                        buffer: se,
                        tests: {},
                        excludes: {},
                        metadata: t,
                        maskLength: se,
                        jitOffset: {}
                    };
                    if (s !== true) {
                        de.prototype.masksCache[o] = r;
                        r = re.extend(true, {}, de.prototype.masksCache[o])
                    }
                } else r = re.extend(true, {}, de.prototype.masksCache[o]);
                return r
            }
            var t;
            if (re.isFunction(i.mask)) {
                i.mask = i.mask(i)
            }
            if (re.isArray(i.mask)) {
                if (i.mask.length > 1) {
                    if (i.keepStatic === null) {
                        i.keepStatic = "auto";
                        for (var n = 0; n < i.mask.length; n++) {
                            if (i.mask[n].charAt(0) !== i.mask[0].charAt(0)) {
                                i.keepStatic = true;
                                break
                            }
                        }
                    }
                    var a = i.groupmarker[0];
                    re.each(i.isRTL ? i.mask.reverse() : i.mask, function(e, t) {
                        if (a.length > 1) {
                            a += i.groupmarker[1] + i.alternatormarker + i.groupmarker[0]
                        }
                        if (t.mask !== se && !re.isFunction(t.mask)) {
                            a += t.mask
                        } else {
                            a += t
                        }
                    });
                    a += i.groupmarker[1];
                    return e(a, i.mask, i)
                } else i.mask = i.mask.pop()
            }
            if (i.mask && i.mask.mask !== se && !re.isFunction(i.mask.mask)) {
                t = e(i.mask.mask, i.mask, i)
            } else {
                t = e(i.mask, i.mask, i)
            }
            return t
        }

        function me(e) {
            var t = le.createElement("input"),
                i = "on" + e,
                n = i in t;
            if (!n) {
                t.setAttribute(i, "return;");
                n = typeof t[i] === "function"
            }
            t = null;
            return n
        }

        function he(e, t, V) {
            t = t || this.maskset;
            V = V || this.opts;
            var c = this,
                u = this.el,
                g = this.isRTL,
                v, r, s = false,
                f = false,
                y = false,
                k, a = false,
                m, o;
            var d = function e(t, i, n, a, r) {
                var o = V.greedy;
                if (r) V.greedy = false;
                i = i || 0;
                var s = [],
                    l, u = 0,
                    f, c, p = S();
                do {
                    if (t === true && K().validPositions[u]) {
                        c = r && K().validPositions[u].match.optionality === true && K().validPositions[u + 1] === se && (K().validPositions[u].generatedInput === true || K().validPositions[u].input == V.skipOptionalPartCharacter && u > 0) ? h(u, E(u, l, u - 1)) : K().validPositions[u];
                        f = c.match;
                        l = c.locator.slice();
                        s.push(n === true ? c.input : n === false ? f.nativeDef : L(u, f))
                    } else {
                        c = b(u, l, u - 1);
                        f = c.match;
                        l = c.locator.slice();
                        var d = a === true ? false : V.jitMasking !== false ? V.jitMasking : f.jit;
                        if (d === false || d === se || typeof d === "number" && isFinite(d) && d > u) {
                            s.push(n === false ? f.nativeDef : L(u, f))
                        }
                    }
                    if (V.keepStatic === "auto") {
                        if (f.newBlockMarker && f.fn !== null) {
                            V.keepStatic = u - 1
                        }
                    }
                    u++
                } while ((k === se || u < k) && (f.fn !== null || f.def !== "") || i > u);
                if (s[s.length - 1] === "") {
                    s.pop()
                }
                if (n !== false || K().maskLength === se) K().maskLength = u - 1;
                V.greedy = o;
                return s
            };

            function K() {
                return t
            }

            function P(e) {
                var t = K();
                t.buffer = se;
                if (e !== true) {
                    t.validPositions = {};
                    t.p = 0
                }
            }

            function S(e, t, i) {
                var n = -1,
                    a = -1,
                    r = i || K().validPositions;
                if (e === se) e = -1;
                for (var o in r) {
                    var s = parseInt(o);
                    if (r[s] && (t || r[s].generatedInput !== true)) {
                        if (s <= e) n = s;
                        if (s >= e) a = s
                    }
                }
                return n === -1 || n == e ? a : a == -1 ? n : e - n < a - e ? n : a
            }

            function w(e) {
                var t = e.locator[e.alternation];
                if (typeof t == "string" && t.length > 0) {
                    t = t.split(",")[0]
                }
                return t !== se ? t.toString() : ""
            }

            function p(e, t) {
                var i = (e.alternation != se ? e.mloc[w(e)] : e.locator).join("");
                if (i !== "")
                    while (i.length < t) {
                        i += "0"
                    }
                return i
            }

            function h(e, t) {
                e = e > 0 ? e - 1 : 0;
                var i = A(e),
                    n = p(i),
                    a, r, o;
                for (var s = 0; s < t.length; s++) {
                    var l = t[s];
                    a = p(l, n.length);
                    var u = Math.abs(a - n);
                    if (r === se || a !== "" && u < r || o && !V.greedy && o.match.optionality && o.match.newBlockMarker === "master" && (!l.match.optionality || !l.match.newBlockMarker) || o && o.match.optionalQuantifier && !l.match.optionalQuantifier) {
                        r = u;
                        o = l
                    }
                }
                return o
            }

            function b(e, t, i) {
                return K().validPositions[e] || h(e, E(e, t ? t.slice() : t, i))
            }

            function A(e, t) {
                if (K().validPositions[e]) {
                    return K().validPositions[e]
                }
                return (t || E(e))[0]
            }

            function x(e, t) {
                var i = false,
                    n = E(e);
                for (var a = 0; a < n.length; a++) {
                    if (n[a].match && n[a].match.def === t) {
                        i = true;
                        break
                    }
                }
                return i
            }

            function E(N, e, t) {
                var i = K().maskToken,
                    R = e ? t : 0,
                    n = e ? e.slice() : [0],
                    G = [],
                    I = false,
                    B, L = e ? e.join("") : "";

                function H(j, F, e, t) {
                    function T(e, t, i) {
                        function r(i, n) {
                            var a = re.inArray(i, n.matches) === 0;
                            if (!a) {
                                re.each(n.matches, function(e, t) {
                                    if (t.isQuantifier === true) a = r(i, n.matches[e - 1]);
                                    else if (t.hasOwnProperty("matches")) a = r(i, t);
                                    if (a) return false
                                })
                            }
                            return a
                        }

                        function n(e, a, r) {
                            var o, s;
                            if (K().tests[e] || K().validPositions[e]) {
                                re.each(K().tests[e] || [K().validPositions[e]], function(e, t) {
                                    if (t.mloc[a]) {
                                        o = t;
                                        return false
                                    }
                                    var i = r !== se ? r : t.alternation,
                                        n = t.locator[i] !== se ? t.locator[i].toString().indexOf(a) : -1;
                                    if ((s === se || n < s) && n !== -1) {
                                        o = t;
                                        s = n
                                    }
                                })
                            }
                            if (o) {
                                var t = o.locator[o.alternation];
                                var i = o.mloc[a] || o.mloc[t] || o.locator;
                                return i.slice((r !== se ? r : o.alternation) + 1)
                            } else {
                                return r !== se ? n(e, a) : se
                            }
                        }

                        function a(e, t) {
                            function i(e) {
                                var t = [],
                                    i, n;
                                for (var a = 0, r = e.length; a < r; a++) {
                                    if (e.charAt(a) === "-") {
                                        n = e.charCodeAt(a + 1);
                                        while (++i < n) {
                                            t.push(String.fromCharCode(i))
                                        }
                                    } else {
                                        i = e.charCodeAt(a);
                                        t.push(e.charAt(a))
                                    }
                                }
                                return t.join("")
                            }
                            if (V.regex && e.match.fn !== null && t.match.fn !== null) {
                                return i(t.match.def.replace(/[\[\]]/g, "")).indexOf(i(e.match.def.replace(/[\[\]]/g, ""))) !== -1
                            }
                            return e.match.def === t.match.nativeDef
                        }

                        function o(e, t) {
                            var i = e.locator.slice(e.alternation).join(""),
                                n = t.locator.slice(t.alternation).join(""),
                                a = i == n;
                            a = a && e.match.fn === null && t.match.fn !== null ? t.match.fn.test(e.match.def, K(), N, false, V, false) : false;
                            return a
                        }

                        function s(e, t) {
                            if (t === se || e.alternation === t.alternation && e.locator[e.alternation].toString().indexOf(t.locator[t.alternation]) === -1) {
                                e.mloc = e.mloc || {};
                                var i = e.locator[e.alternation];
                                if (i === se) e.alternation = se;
                                else {
                                    if (typeof i === "string") i = i.split(",")[0];
                                    if (e.mloc[i] === se) e.mloc[i] = e.locator.slice();
                                    if (t !== se) {
                                        for (var n in t.mloc) {
                                            if (typeof n === "string") n = n.split(",")[0];
                                            if (e.mloc[n] === se) e.mloc[n] = t.mloc[n]
                                        }
                                        e.locator[e.alternation] = Object.keys(e.mloc).join(",")
                                    }
                                    return true
                                }
                            }
                            return false
                        }
                        if (R > 500 && i !== se) {
                            throw "Inputmask: There is probably an error in your mask definition or in the code. Create an issue on github with an example of the mask you are using. " + K().mask
                        }
                        if (R === N && e.matches === se) {
                            G.push({
                                match: e,
                                locator: t.reverse(),
                                cd: L,
                                mloc: {}
                            });
                            return true
                        } else if (e.matches !== se) {
                            if (e.isGroup && i !== e) {
                                e = T(j.matches[re.inArray(e, j.matches) + 1], t, i);
                                if (e) return true
                            } else if (e.isOptional) {
                                var l = e;
                                e = H(e, F, t, i);
                                if (e) {
                                    re.each(G, function(e, t) {
                                        t.match.optionality = true
                                    });
                                    B = G[G.length - 1].match;
                                    if (i === se && r(B, l)) {
                                        I = true;
                                        R = N
                                    } else return true
                                }
                            } else if (e.isAlternator) {
                                var u = e,
                                    f = [],
                                    c, p = G.slice(),
                                    d = t.length;
                                var m = F.length > 0 ? F.shift() : -1;
                                if (m === -1 || typeof m === "string") {
                                    var h = R,
                                        g = F.slice(),
                                        v = [],
                                        k;
                                    if (typeof m == "string") {
                                        v = m.split(",")
                                    } else {
                                        for (k = 0; k < u.matches.length; k++) {
                                            v.push(k.toString())
                                        }
                                    }
                                    if (K().excludes[N]) {
                                        var y = v.slice();
                                        for (var b = 0, x = K().excludes[N].length; b < x; b++) {
                                            v.splice(v.indexOf(K().excludes[N][b].toString()), 1)
                                        }
                                        if (v.length === 0) {
                                            K().excludes[N] = se;
                                            v = y
                                        }
                                    }
                                    if (V.keepStatic === true || isFinite(parseInt(V.keepStatic)) && h >= V.keepStatic) v = v.slice(0, 1);
                                    var P = false;
                                    for (var S = 0; S < v.length; S++) {
                                        k = parseInt(v[S]);
                                        G = [];
                                        F = typeof m === "string" ? n(R, k, d) || g.slice() : g.slice();
                                        if (u.matches[k] && T(u.matches[k], [k].concat(t), i)) e = true;
                                        else if (S === 0) {
                                            P = true
                                        }
                                        c = G.slice();
                                        R = h;
                                        G = [];
                                        for (var w = 0; w < c.length; w++) {
                                            var A = c[w],
                                                E = false;
                                            A.match.jit = A.match.jit || P;
                                            A.alternation = A.alternation || d;
                                            s(A);
                                            for (var _ = 0; _ < f.length; _++) {
                                                var C = f[_];
                                                if (typeof m !== "string" || A.alternation !== se && re.inArray(A.locator[A.alternation].toString(), v) !== -1) {
                                                    if (A.match.nativeDef === C.match.nativeDef) {
                                                        E = true;
                                                        s(C, A);
                                                        break
                                                    } else if (a(A, C)) {
                                                        if (s(A, C)) {
                                                            E = true;
                                                            f.splice(f.indexOf(C), 0, A)
                                                        }
                                                        break
                                                    } else if (a(C, A)) {
                                                        s(C, A);
                                                        break
                                                    } else if (o(A, C)) {
                                                        if (s(A, C)) {
                                                            E = true;
                                                            f.splice(f.indexOf(C), 0, A)
                                                        }
                                                        break
                                                    }
                                                }
                                            }
                                            if (!E) {
                                                f.push(A)
                                            }
                                        }
                                    }
                                    G = p.concat(f);
                                    R = N;
                                    I = G.length > 0;
                                    e = f.length > 0;
                                    F = g.slice()
                                } else e = T(u.matches[m] || j.matches[m], [m].concat(t), i);
                                if (e) return true
                            } else if (e.isQuantifier && i !== j.matches[re.inArray(e, j.matches) - 1]) {
                                var D = e;
                                for (var M = F.length > 0 ? F.shift() : 0; M < (isNaN(D.quantifier.max) ? M + 1 : D.quantifier.max) && R <= N; M++) {
                                    var O = j.matches[re.inArray(D, j.matches) - 1];
                                    e = T(O, [M].concat(t), O);
                                    if (e) {
                                        B = G[G.length - 1].match;
                                        B.optionalQuantifier = M >= D.quantifier.min;
                                        B.jit = (M || 1) * O.matches.indexOf(B) >= D.quantifier.jit;
                                        if (B.optionalQuantifier && r(B, O)) {
                                            I = true;
                                            R = N;
                                            break
                                        }
                                        if (B.jit) {
                                            K().jitOffset[N] = O.matches.indexOf(B)
                                        }
                                        return true
                                    }
                                }
                            } else {
                                e = H(e, F, t, i);
                                if (e) return true
                            }
                        } else {
                            R++
                        }
                    }
                    for (var i = F.length > 0 ? F.shift() : 0; i < j.matches.length; i++) {
                        if (j.matches[i].isQuantifier !== true) {
                            var n = T(j.matches[i], [i].concat(e), t);
                            if (n && R === N) {
                                return n
                            } else if (R > N) {
                                break
                            }
                        }
                    }
                }

                function a(e, t) {
                    var n = [];
                    if (!re.isArray(t)) t = [t];
                    if (t.length > 0) {
                        if (t[0].alternation === se) {
                            n = h(e, t.slice()).locator.slice();
                            if (n.length === 0) n = t[0].locator.slice()
                        } else {
                            re.each(t, function(e, t) {
                                if (t.def !== "") {
                                    if (n.length === 0) n = t.locator.slice();
                                    else {
                                        for (var i = 0; i < n.length; i++) {
                                            if (t.locator[i] && n[i].toString().indexOf(t.locator[i]) === -1) {
                                                n[i] += "," + t.locator[i]
                                            }
                                        }
                                    }
                                }
                            })
                        }
                    }
                    return n
                }
                if (N > -1) {
                    if (e === se) {
                        var r = N - 1,
                            o;
                        while ((o = K().validPositions[r] || K().tests[r]) === se && r > -1) {
                            r--
                        }
                        if (o !== se && r > -1) {
                            n = a(r, o);
                            L = n.join("");
                            R = r
                        }
                    }
                    if (K().tests[N] && K().tests[N][0].cd === L) {
                        return K().tests[N]
                    }
                    for (var s = n.shift(); s < i.length; s++) {
                        var l = H(i[s], n, [s]);
                        if (l && R === N || R > N) {
                            break
                        }
                    }
                }
                if (G.length === 0 || I) {
                    G.push({
                        match: {
                            fn: null,
                            optionality: false,
                            casing: null,
                            def: "",
                            placeholder: ""
                        },
                        locator: [],
                        mloc: {},
                        cd: L
                    })
                }
                if (e !== se && K().tests[N]) {
                    return re.extend(true, [], G)
                }
                K().tests[N] = re.extend(true, [], G);
                return K().tests[N]
            }

            function _() {
                if (K()._buffer === se) {
                    K()._buffer = d(false, 1);
                    if (K().buffer === se) K().buffer = K()._buffer.slice()
                }
                return K()._buffer
            }

            function C(e) {
                if (K().buffer === se || e === true) {
                    K().buffer = d(true, S(), true);
                    if (K()._buffer === se) K()._buffer = K().buffer.slice()
                }
                return K().buffer
            }

            function D(e, t, i) {
                var n, a;
                if (e === true) {
                    P();
                    e = 0;
                    t = i.length
                } else {
                    for (n = e; n < t; n++) {
                        delete K().validPositions[n]
                    }
                }
                a = e;
                for (n = e; n < t; n++) {
                    P(true);
                    if (i[n] !== V.skipOptionalPartCharacter) {
                        var r = F(a, i[n], true, true);
                        if (r !== false) {
                            P(true);
                            a = r.caret !== se ? r.caret : r.pos + 1
                        }
                    }
                }
            }

            function M(e, t, i) {
                switch (V.casing || t.casing) {
                    case "upper":
                        e = e.toUpperCase();
                        break;
                    case "lower":
                        e = e.toLowerCase();
                        break;
                    case "title":
                        var n = K().validPositions[i - 1];
                        if (i === 0 || n && n.input === String.fromCharCode(de.keyCode.SPACE)) {
                            e = e.toUpperCase()
                        } else {
                            e = e.toLowerCase()
                        }
                        break;
                    default:
                        if (re.isFunction(V.casing)) {
                            var a = Array.prototype.slice.call(arguments);
                            a.push(K().validPositions);
                            e = V.casing.apply(this, a)
                        }
                }
                return e
            }

            function O(e, t, i) {
                var n = V.greedy ? t : t.slice(0, 1),
                    a = false,
                    r = i !== se ? i.split(",") : [],
                    o;
                for (var s = 0; s < r.length; s++) {
                    if ((o = e.indexOf(r[s])) !== -1) {
                        e.splice(o, 1)
                    }
                }
                for (var l = 0; l < e.length; l++) {
                    if (re.inArray(e[l], n) !== -1) {
                        a = true;
                        break
                    }
                }
                return a
            }

            function j(e, t, i, n, a) {
                var r = re.extend(true, {}, K().validPositions),
                    o, s, l = false,
                    u, f, c, p, d, m = a !== se ? a : S();
                if (m === -1 && a === se) {
                    o = 0;
                    f = A(o);
                    s = f.alternation
                } else {
                    for (; m >= 0; m--) {
                        u = K().validPositions[m];
                        if (u && u.alternation !== se) {
                            if (f && f.locator[u.alternation] !== u.locator[u.alternation]) {
                                break
                            }
                            o = m;
                            s = K().validPositions[o].alternation;
                            f = u
                        }
                    }
                }
                if (s !== se) {
                    d = parseInt(o);
                    K().excludes[d] = K().excludes[d] || [];
                    if (e !== true) {
                        K().excludes[d].push(w(f))
                    }
                    var h = [],
                        g = 0;
                    for (c = d; c < S(se, true) + 1; c++) {
                        p = K().validPositions[c];
                        if (p && p.generatedInput !== true) {
                            h.push(p.input)
                        } else if (c < e) g++;
                        delete K().validPositions[c]
                    }
                    while (K().excludes[d] && K().excludes[d].length < 10) {
                        var v = g * -1,
                            k = h.slice();
                        K().tests[d] = se;
                        P(true);
                        l = true;
                        while (k.length > 0) {
                            var y = k.shift();
                            if (!(l = F(S(se, true) + 1, y, false, n, true))) {
                                break
                            }
                        }
                        if (l && t !== se) {
                            var b = S(e) + 1;
                            for (c = d; c < S() + 1; c++) {
                                p = K().validPositions[c];
                                if ((p === se || p.match.fn == null) && c < e + v) {
                                    v++
                                }
                            }
                            e = e + v;
                            l = F(e > b ? b : e, t, i, n, true)
                        }
                        if (!l) {
                            P();
                            f = A(d);
                            K().validPositions = re.extend(true, {}, r);
                            if (K().excludes[d]) {
                                var x = w(f);
                                if (K().excludes[d].indexOf(x) !== -1) {
                                    l = j(e, t, i, n, d - 1);
                                    break
                                }
                                K().excludes[d].push(x);
                                for (c = d; c < S(se, true) + 1; c++) {
                                    delete K().validPositions[c]
                                }
                            } else {
                                l = j(e, t, i, n, d - 1);
                                break
                            }
                        } else break
                    }
                }
                K().excludes[d] = se;
                return l
            }

            function F(u, e, t, f, i, n) {
                function c(e) {
                    return g ? e.begin - e.end > 1 || e.begin - e.end === 1 : e.end - e.begin > 1 || e.end - e.begin === 1
                }
                t = t === true;
                var a = u;
                if (u.begin !== se) {
                    a = g ? u.end : u.begin
                }

                function r(r, o, s) {
                    var l = false;
                    re.each(E(r), function(e, t) {
                        var i = t.match;
                        C(true);
                        l = i.fn != null ? i.fn.test(o, K(), r, s, V, c(u)) : (o === i.def || o === V.skipOptionalPartCharacter) && i.def !== "" ? {
                            c: L(r, i, true) || i.def,
                            pos: r
                        } : false;
                        if (l !== false) {
                            var n = l.c !== se ? l.c : o,
                                a = r;
                            n = n === V.skipOptionalPartCharacter && i.fn === null ? L(r, i, true) || i.def : n;
                            if (l.remove !== se) {
                                if (!re.isArray(l.remove)) l.remove = [l.remove];
                                re.each(l.remove.sort(function(e, t) {
                                    return t - e
                                }), function(e, t) {
                                    N({
                                        begin: t,
                                        end: t + 1
                                    })
                                })
                            }
                            if (l.insert !== se) {
                                if (!re.isArray(l.insert)) l.insert = [l.insert];
                                re.each(l.insert.sort(function(e, t) {
                                    return e - t
                                }), function(e, t) {
                                    F(t.pos, t.c, true, f)
                                })
                            }
                            if (l !== true && l.pos !== se && l.pos !== r) {
                                a = l.pos
                            }
                            if (l !== true && l.pos === se && l.c === se) {
                                return false
                            }
                            if (!N(u, re.extend({}, t, {
                                    input: M(n, i, a)
                                }), f, a)) {
                                l = false
                            }
                            return false
                        }
                    });
                    return l
                }
                var o = true,
                    s = re.extend(true, {}, K().validPositions);
                if (re.isFunction(V.preValidation) && !t && f !== true && n !== true) {
                    o = V.preValidation(C(), a, e, c(u), V, K())
                }
                if (o === true) {
                    T(se, a, true);
                    if (k === se || a < k) {
                        o = r(a, e, t);
                        if ((!t || f === true) && o === false && n !== true) {
                            var l = K().validPositions[a];
                            if (l && l.match.fn === null && (l.match.def === e || e === V.skipOptionalPartCharacter)) {
                                o = {
                                    caret: G(a)
                                }
                            } else {
                                if ((V.insertMode || K().validPositions[G(a)] === se) && (!R(a, true) || K().jitOffset[a])) {
                                    if (K().jitOffset[a] && K().validPositions[G(a)] === se) {
                                        o = F(a + K().jitOffset[a], e, t);
                                        if (o !== false) o.caret = a
                                    } else
                                        for (var p = a + 1, d = G(a); p <= d; p++) {
                                            o = r(p, e, t);
                                            if (o !== false) {
                                                o = T(a, o.pos !== se ? o.pos : p) || o;
                                                a = p;
                                                break
                                            }
                                        }
                                }
                            }
                        }
                    }
                    if (o === false && V.keepStatic !== false && (V.regex == null || $(C())) && !t && i !== true) {
                        o = j(a, e, t, f)
                    }
                    if (o === true) {
                        o = {
                            pos: a
                        }
                    }
                }
                if (re.isFunction(V.postValidation) && o !== false && !t && f !== true && n !== true) {
                    var m = V.postValidation(C(true), u.begin !== se ? g ? u.end : u.begin : u, o, V);
                    if (m !== se) {
                        if (m.refreshFromBuffer && m.buffer) {
                            var h = m.refreshFromBuffer;
                            D(h === true ? h : h.start, h.end, m.buffer)
                        }
                        o = m === true ? o : m
                    }
                }
                if (o && o.pos === se) {
                    o.pos = a
                }
                if (o === false || n === true) {
                    P(true);
                    K().validPositions = re.extend(true, {}, s)
                }
                return o
            }

            function T(e, t, i) {
                var n;
                if (e === se) {
                    for (e = t - 1; e > 0; e--) {
                        if (K().validPositions[e]) break
                    }
                }
                for (var a = e; a < t; a++) {
                    if (K().validPositions[a] === se && !R(a, true)) {
                        var r = a == 0 ? A(a) : K().validPositions[a - 1];
                        if (r) {
                            var o = E(a).slice();
                            if (o[o.length - 1].match.def === "") o.pop();
                            var s = h(a, o);
                            s = re.extend({}, s, {
                                input: L(a, s.match, true) || s.match.def
                            });
                            s.generatedInput = true;
                            N(a, s, true);
                            if (i !== true) {
                                var l = K().validPositions[t].input;
                                K().validPositions[t] = se;
                                n = F(t, l, true, true)
                            }
                        }
                    }
                }
                return n
            }

            function N(e, t, i, n) {
                function a(e, t, i) {
                    var n = t[e];
                    if (n !== se && (n.match.fn === null && n.match.optionality !== true || n.input === V.radixPoint)) {
                        var a = i.begin <= e - 1 ? t[e - 1] && t[e - 1].match.fn === null && t[e - 1] : t[e - 1],
                            r = i.end > e + 1 ? t[e + 1] && t[e + 1].match.fn === null && t[e + 1] : t[e + 1];
                        return a && r
                    }
                    return false
                }
                var r = e.begin !== se ? e.begin : e,
                    o = e.end !== se ? e.end : e;
                if (e.begin > e.end) {
                    r = e.end;
                    o = e.begin
                }
                n = n !== se ? n : r;
                if (r !== o || V.insertMode && K().validPositions[n] !== se && i === se) {
                    var s = re.extend(true, {}, K().validPositions),
                        l = S(se, true),
                        u;
                    K().p = r;
                    for (u = l; u >= r; u--) {
                        if (K().validPositions[u] && K().validPositions[u].match.nativeDef === "+") {
                            V.isNegative = false
                        }
                        delete K().validPositions[u]
                    }
                    var f = true,
                        c = n,
                        p = K().validPositions,
                        d = false,
                        m = c,
                        u = c;
                    if (t) {
                        K().validPositions[n] = re.extend(true, {}, t);
                        m++;
                        c++;
                        if (r < o) u++
                    }
                    for (; u <= l; u++) {
                        var h = s[u];
                        if (h !== se && (u >= o || u >= r && h.generatedInput !== true && a(u, s, {
                                begin: r,
                                end: o
                            }))) {
                            while (A(m).match.def !== "") {
                                if (d === false && s[m] && s[m].match.nativeDef === h.match.nativeDef) {
                                    K().validPositions[m] = re.extend(true, {}, s[m]);
                                    K().validPositions[m].input = h.input;
                                    T(se, m, true);
                                    c = m + 1;
                                    f = true
                                } else if (V.shiftPositions && x(m, h.match.def)) {
                                    var g = F(m, h.input, true, true);
                                    f = g !== false;
                                    c = g.caret || g.insert ? S() : m + 1;
                                    d = true
                                } else {
                                    f = h.generatedInput === true || h.input === V.radixPoint && V.numericInput === true
                                }
                                if (f) break;
                                if (!f && m > o && R(m, true) && (h.match.fn !== null || m > K().maskLength)) {
                                    break
                                }
                                m++
                            }
                            if (A(m).match.def == "") f = false;
                            m = c
                        }
                        if (!f) break
                    }
                    if (!f) {
                        K().validPositions = re.extend(true, {}, s);
                        P(true);
                        return false
                    }
                } else if (t) {
                    K().validPositions[n] = re.extend(true, {}, t)
                }
                P(true);
                return true
            }

            function R(e, t) {
                var i = b(e).match;
                if (i.def === "") i = A(e).match;
                if (i.fn != null) {
                    return i.fn
                }
                if (t !== true && e > -1) {
                    var n = E(e);
                    return n.length > 1 + (n[n.length - 1].match.def === "" ? 1 : 0)
                }
                return false
            }

            function G(e, t) {
                var i = e + 1;
                while (A(i).match.def !== "" && (t === true && (A(i).match.newBlockMarker !== true || !R(i)) || t !== true && !R(i))) {
                    i++
                }
                return i
            }

            function I(e, t) {
                var i = e,
                    n;
                if (i <= 0) return 0;
                while (--i > 0 && (t === true && A(i).match.newBlockMarker !== true || t !== true && !R(i) && (n = E(i), n.length < 2 || n.length === 2 && n[1].match.def === ""))) {}
                return i
            }

            function B(e, t, i, n, a) {
                if (n && re.isFunction(V.onBeforeWrite)) {
                    var r = V.onBeforeWrite.call(c, n, t, i, V);
                    if (r) {
                        if (r.refreshFromBuffer) {
                            var o = r.refreshFromBuffer;
                            D(o === true ? o : o.start, o.end, r.buffer || t);
                            t = C(true)
                        }
                        if (i !== se) i = r.caret !== se ? r.caret : i
                    }
                }
                if (e !== se) {
                    e.inputmask._valueSet(t.join(""));
                    if (i !== se && (n === se || n.type !== "blur")) {
                        W(e, i)
                    } else Y(e, i, t.length === 0);
                    if (a === true) {
                        var s = re(e),
                            l = e.inputmask._valueGet();
                        f = true;
                        s.trigger("input");
                        setTimeout(function() {
                            if (l === _().join("")) {
                                s.trigger("cleared")
                            } else if ($(t) === true) {
                                s.trigger("complete")
                            }
                        }, 0)
                    }
                }
            }

            function L(e, t, i) {
                t = t || A(e).match;
                if (t.placeholder !== se || i === true) {
                    return re.isFunction(t.placeholder) ? t.placeholder(V) : t.placeholder
                } else if (t.fn === null) {
                    if (e > -1 && K().validPositions[e] === se) {
                        var n = E(e),
                            a = [],
                            r;
                        if (n.length > 1 + (n[n.length - 1].match.def === "" ? 1 : 0)) {
                            for (var o = 0; o < n.length; o++) {
                                if (n[o].match.optionality !== true && n[o].match.optionalQuantifier !== true && (n[o].match.fn === null || r === se || n[o].match.fn.test(r.match.def, K(), e, true, V) !== false)) {
                                    a.push(n[o]);
                                    if (n[o].match.fn === null) r = n[o];
                                    if (a.length > 1) {
                                        if (/[0-9a-bA-Z]/.test(a[0].match.def)) {
                                            return V.placeholder.charAt(e % V.placeholder.length)
                                        }
                                    }
                                }
                            }
                        }
                    }
                    return t.def
                }
                return V.placeholder.charAt(e % V.placeholder.length)
            }

            function l(e, t) {
                if (ue) {
                    if (e.inputmask._valueGet() !== t && (e.placeholder !== t || e.placeholder === "")) {
                        var i = C().slice(),
                            n = e.inputmask._valueGet();
                        if (n !== t) {
                            var a = S();
                            if (a === -1 && n === _().join("")) {
                                i = []
                            } else if (a !== -1) {
                                Q(i)
                            }
                            B(e, i)
                        }
                    }
                } else if (e.placeholder !== t) {
                    e.placeholder = t;
                    if (e.placeholder === "") e.removeAttribute("placeholder")
                }
            }
            var H = {
                on: function e(t, i, o) {
                    var n = function e(t) {
                        var i = this;
                        if (i.inputmask === se && this.nodeName !== "FORM") {
                            var n = re.data(i, "_inputmask_opts");
                            if (n) new de(n).mask(i);
                            else H.off(i)
                        } else if (t.type !== "setvalue" && this.nodeName !== "FORM" && (i.disabled || i.readOnly && !(t.type === "keydown" && t.ctrlKey && t.keyCode === 67 || V.tabThrough === false && t.keyCode === de.keyCode.TAB))) {
                            t.preventDefault()
                        } else {
                            switch (t.type) {
                                case "input":
                                    if (f === true) {
                                        f = false;
                                        return t.preventDefault()
                                    }
                                    if (fe) {
                                        var a = arguments;
                                        setTimeout(function() {
                                            o.apply(i, a);
                                            W(i, i.inputmask.caretPos, se, true)
                                        }, 0);
                                        return false
                                    }
                                    break;
                                case "keydown":
                                    s = false;
                                    f = false;
                                    break;
                                case "keypress":
                                    if (s === true) {
                                        return t.preventDefault()
                                    }
                                    s = true;
                                    break;
                                case "click":
                                    if (ce || pe) {
                                        var a = arguments;
                                        setTimeout(function() {
                                            o.apply(i, a)
                                        }, 0);
                                        return false
                                    }
                                    break
                            }
                            var r = o.apply(i, arguments);
                            if (r === false) {
                                t.preventDefault();
                                t.stopPropagation()
                            }
                            return r
                        }
                    };
                    t.inputmask.events[i] = t.inputmask.events[i] || [];
                    t.inputmask.events[i].push(n);
                    if (re.inArray(i, ["submit", "reset"]) !== -1) {
                        if (t.form !== null) re(t.form).on(i, n)
                    } else {
                        re(t).on(i, n)
                    }
                },
                off: function e(n, t) {
                    if (n.inputmask && n.inputmask.events) {
                        var i;
                        if (t) {
                            i = [];
                            i[t] = n.inputmask.events[t]
                        } else {
                            i = n.inputmask.events
                        }
                        re.each(i, function(e, t) {
                            while (t.length > 0) {
                                var i = t.pop();
                                if (re.inArray(e, ["submit", "reset"]) !== -1) {
                                    if (n.form !== null) re(n.form).off(e, i)
                                } else {
                                    re(n).off(e, i)
                                }
                            }
                            delete n.inputmask.events[e]
                        })
                    }
                }
            };
            var U = {
                keydownEvent: function e(t) {
                    var i = this,
                        n = re(i),
                        a = t.keyCode,
                        r = W(i);
                    if (a === de.keyCode.BACKSPACE || a === de.keyCode.DELETE || pe && a === de.keyCode.BACKSPACE_SAFARI || t.ctrlKey && a === de.keyCode.X && !me("cut")) {
                        t.preventDefault();
                        Z(i, a, r);
                        B(i, C(true), K().p, t, i.inputmask._valueGet() !== C().join(""))
                    } else if (a === de.keyCode.END || a === de.keyCode.PAGE_DOWN) {
                        t.preventDefault();
                        var o = G(S());
                        W(i, t.shiftKey ? r.begin : o, o, true)
                    } else if (a === de.keyCode.HOME && !t.shiftKey || a === de.keyCode.PAGE_UP) {
                        t.preventDefault();
                        W(i, 0, t.shiftKey ? r.begin : 0, true)
                    } else if ((V.undoOnEscape && a === de.keyCode.ESCAPE || a === 90 && t.ctrlKey) && t.altKey !== true) {
                        z(i, true, false, v.split(""));
                        n.trigger("click")
                    } else if (a === de.keyCode.INSERT && !(t.shiftKey || t.ctrlKey)) {
                        V.insertMode = !V.insertMode;
                        i.setAttribute("im-insert", V.insertMode)
                    } else if (V.tabThrough === true && a === de.keyCode.TAB) {
                        if (t.shiftKey === true) {
                            if (A(r.begin).match.fn === null) {
                                r.begin = G(r.begin)
                            }
                            r.end = I(r.begin, true);
                            r.begin = I(r.end, true)
                        } else {
                            r.begin = G(r.begin, true);
                            r.end = G(r.begin, true);
                            if (r.end < K().maskLength) r.end--
                        }
                        if (r.begin < K().maskLength) {
                            t.preventDefault();
                            W(i, r.begin, r.end)
                        }
                    }
                    V.onKeyDown.call(this, t, C(), W(i).begin, V);
                    y = re.inArray(a, V.ignorables) !== -1
                },
                keypressEvent: function e(t, i, n, a, r) {
                    var o = this,
                        s = re(o),
                        l = t.which || t.charCode || t.keyCode;
                    if (i !== true && !(t.ctrlKey && t.altKey) && (t.ctrlKey || t.metaKey || y)) {
                        if (l === de.keyCode.ENTER && v !== C().join("")) {
                            v = C().join("");
                            setTimeout(function() {
                                s.trigger("change")
                            }, 0)
                        }
                        return true
                    } else {
                        if (l) {
                            if (l === 46 && t.shiftKey === false && V.radixPoint !== "") l = V.radixPoint.charCodeAt(0);
                            var u = i ? {
                                    begin: r,
                                    end: r
                                } : W(o),
                                f, c = String.fromCharCode(l),
                                p = 0;
                            if (V._radixDance && V.numericInput) {
                                var d = C().indexOf(V.radixPoint.charAt(0)) + 1;
                                if (u.begin <= d) {
                                    if (l === V.radixPoint.charCodeAt(0)) p = 1;
                                    u.begin -= 1;
                                    u.end -= 1
                                }
                            }
                            K().writeOutBuffer = true;
                            var m = F(u, c, a);
                            if (m !== false) {
                                P(true);
                                f = m.caret !== se ? m.caret : G(m.pos.begin ? m.pos.begin : m.pos);
                                K().p = f
                            }
                            f = (V.numericInput && m.caret === se ? I(f) : f) + p;
                            if (n !== false) {
                                setTimeout(function() {
                                    V.onKeyValidation.call(o, l, m, V)
                                }, 0);
                                if (K().writeOutBuffer && m !== false) {
                                    var h = C();
                                    B(o, h, f, t, i !== true)
                                }
                            }
                            t.preventDefault();
                            if (i) {
                                if (m !== false) m.forwardPosition = f;
                                return m
                            }
                        }
                    }
                },
                pasteEvent: function e(t) {
                    var i = this,
                        n = t.originalEvent || t,
                        a = re(i),
                        r = i.inputmask._valueGet(true),
                        o = W(i),
                        s;
                    if (g) {
                        s = o.end;
                        o.end = o.begin;
                        o.begin = s
                    }
                    var l = r.substr(0, o.begin),
                        u = r.substr(o.end, r.length);
                    if (l === (g ? _().reverse() : _()).slice(0, o.begin).join("")) l = "";
                    if (u === (g ? _().reverse() : _()).slice(o.end).join("")) u = "";
                    if (oe.clipboardData && oe.clipboardData.getData) {
                        r = l + oe.clipboardData.getData("Text") + u
                    } else if (n.clipboardData && n.clipboardData.getData) {
                        r = l + n.clipboardData.getData("text/plain") + u
                    } else return true;
                    var f = r;
                    if (re.isFunction(V.onBeforePaste)) {
                        f = V.onBeforePaste.call(c, r, V);
                        if (f === false) {
                            return t.preventDefault()
                        }
                        if (!f) {
                            f = r
                        }
                    }
                    z(i, false, false, f.toString().split(""));
                    B(i, C(), G(S()), t, v !== C().join(""));
                    return t.preventDefault()
                },
                inputFallBackEvent: function e(t) {
                    function i(e, t, i) {
                        if (t.charAt(i.begin - 1) === "." && V.radixPoint !== "") {
                            t = t.split("");
                            t[i.begin - 1] = V.radixPoint.charAt(0);
                            t = t.join("")
                        }
                        return t
                    }

                    function n(e, t, i) {
                        if (ce) {
                            var n = t.replace(C().join(""), "");
                            if (n.length === 1) {
                                var a = t.split("");
                                a.splice(i.begin, 0, n);
                                t = a.join("")
                            }
                        }
                        return t
                    }
                    var a = this,
                        r = a.inputmask._valueGet();
                    if (C().join("") !== r) {
                        var o = W(a);
                        r = i(a, r, o);
                        r = n(a, r, o);
                        if (C().join("") !== r) {
                            var s = C().join(""),
                                l = !V.numericInput && r.length > s.length ? -1 : 0,
                                u = r.substr(0, o.begin),
                                f = r.substr(o.begin),
                                c = s.substr(0, o.begin + l),
                                p = s.substr(o.begin + l);
                            var d = o,
                                m = "",
                                h = false;
                            if (u !== c) {
                                var g = (h = u.length >= c.length) ? u.length : c.length,
                                    v;
                                for (v = 0; u.charAt(v) === c.charAt(v) && v < g; v++) {}
                                if (h) {
                                    d.begin = v - l;
                                    m += u.slice(v, d.end)
                                }
                            }
                            if (f !== p) {
                                if (f.length > p.length) {
                                    m += f.slice(0, 1)
                                } else {
                                    if (f.length < p.length) {
                                        d.end += p.length - f.length;
                                        if (!h && V.radixPoint !== "" && f === "" && u.charAt(d.begin + l - 1) === V.radixPoint) {
                                            d.begin--;
                                            m = V.radixPoint
                                        }
                                    }
                                }
                            }
                            B(a, C(), {
                                begin: d.begin + l,
                                end: d.end + l
                            });
                            if (m.length > 0) {
                                re.each(m.split(""), function(e, t) {
                                    var i = new re.Event("keypress");
                                    i.which = t.charCodeAt(0);
                                    y = false;
                                    U.keypressEvent.call(a, i)
                                })
                            } else {
                                if (d.begin === d.end - 1) {
                                    d.begin = I(d.begin + 1);
                                    if (d.begin === d.end - 1) {
                                        W(a, d.begin)
                                    } else {
                                        W(a, d.begin, d.end)
                                    }
                                }
                                var k = new re.Event("keydown");
                                k.keyCode = V.numericInput ? de.keyCode.BACKSPACE : de.keyCode.DELETE;
                                U.keydownEvent.call(a, k)
                            }
                            t.preventDefault()
                        }
                    }
                },
                beforeInputEvent: function e(t) {
                    if (t.cancelable) {
                        var n = this;
                        switch (t.inputType) {
                            case "insertText":
                                re.each(t.data.split(""), function(e, t) {
                                    var i = new re.Event("keypress");
                                    i.which = t.charCodeAt(0);
                                    y = false;
                                    U.keypressEvent.call(n, i)
                                });
                                return t.preventDefault();
                            case "deleteContentBackward":
                                var i = new re.Event("keydown");
                                i.keyCode = de.keyCode.BACKSPACE;
                                U.keydownEvent.call(n, i);
                                return t.preventDefault();
                            case "deleteContentForward":
                                var i = new re.Event("keydown");
                                i.keyCode = de.keyCode.DELETE;
                                U.keydownEvent.call(n, i);
                                return t.preventDefault()
                        }
                    }
                },
                setValueEvent: function e(t) {
                    this.inputmask.refreshValue = false;
                    var i = this,
                        n = t && t.detail ? t.detail[0] : arguments[1],
                        n = n || i.inputmask._valueGet(true);
                    if (re.isFunction(V.onBeforeMask)) n = V.onBeforeMask.call(c, n, V) || n;
                    n = n.toString().split("");
                    z(i, true, false, n);
                    v = C().join("");
                    if ((V.clearMaskOnLostFocus || V.clearIncomplete) && i.inputmask._valueGet() === _().join("")) {
                        i.inputmask._valueSet("")
                    }
                },
                focusEvent: function e(t) {
                    var i = this,
                        n = i.inputmask._valueGet();
                    if (V.showMaskOnFocus) {
                        if (n !== C().join("")) {
                            B(i, C(), G(S()))
                        } else if (a === false) {
                            W(i, G(S()))
                        }
                    }
                    if (V.positionCaretOnTab === true && a === false) {
                        U.clickEvent.apply(i, [t, true])
                    }
                    v = C().join("")
                },
                mouseleaveEvent: function e(t) {
                    var i = this;
                    a = false;
                    if (V.clearMaskOnLostFocus && le.activeElement !== i) {
                        l(i, o)
                    }
                },
                clickEvent: function e(t, u) {
                    function f(e) {
                        if (V.radixPoint !== "") {
                            var t = K().validPositions;
                            if (t[e] === se || t[e].input === L(e)) {
                                if (e < G(-1)) return true;
                                var i = re.inArray(V.radixPoint, C());
                                if (i !== -1) {
                                    for (var n in t) {
                                        if (i < n && t[n].input !== L(n)) {
                                            return false
                                        }
                                    }
                                    return true
                                }
                            }
                        }
                        return false
                    }
                    var c = this;
                    setTimeout(function() {
                        if (le.activeElement === c) {
                            var e = W(c);
                            if (u) {
                                if (g) {
                                    e.end = e.begin
                                } else {
                                    e.begin = e.end
                                }
                            }
                            if (e.begin === e.end) {
                                switch (V.positionCaretOnClick) {
                                    case "none":
                                        break;
                                    case "select":
                                        W(c, 0, C().length);
                                        break;
                                    case "ignore":
                                        W(c, G(S()));
                                        break;
                                    case "radixFocus":
                                        if (f(e.begin)) {
                                            var t = C().join("").indexOf(V.radixPoint);
                                            W(c, V.numericInput ? G(t) : t);
                                            break
                                        }
                                    default:
                                        var i = e.begin,
                                            n = S(i, true),
                                            a = G(n);
                                        if (i < a) {
                                            W(c, !R(i, true) && !R(i - 1, true) ? G(i) : i)
                                        } else {
                                            var r = K().validPositions[n],
                                                o = b(a, r ? r.match.locator : se, r),
                                                s = L(a, o.match);
                                            if (s !== "" && C()[a] !== s && o.match.optionalQuantifier !== true && o.match.newBlockMarker !== true || !R(a, V.keepStatic) && o.match.def === s) {
                                                var l = G(a);
                                                if (i >= l || i === a) {
                                                    a = l
                                                }
                                            }
                                            W(c, a)
                                        }
                                        break
                                }
                            }
                        }
                    }, 0)
                },
                cutEvent: function e(t) {
                    var i = this,
                        n = re(i),
                        a = W(i),
                        r = t.originalEvent || t;
                    var o = oe.clipboardData || r.clipboardData,
                        s = g ? C().slice(a.end, a.begin) : C().slice(a.begin, a.end);
                    o.setData("text", g ? s.reverse().join("") : s.join(""));
                    if (le.execCommand) le.execCommand("copy");
                    Z(i, de.keyCode.DELETE, a);
                    B(i, C(), K().p, t, v !== C().join(""))
                },
                blurEvent: function e(t) {
                    var i = re(this),
                        n = this;
                    if (n.inputmask) {
                        l(n, o);
                        var a = n.inputmask._valueGet(),
                            r = C().slice();
                        if (a !== "" || m !== se) {
                            if (V.clearMaskOnLostFocus) {
                                if (S() === -1 && a === _().join("")) {
                                    r = []
                                } else {
                                    Q(r)
                                }
                            }
                            if ($(r) === false) {
                                setTimeout(function() {
                                    i.trigger("incomplete")
                                }, 0);
                                if (V.clearIncomplete) {
                                    P();
                                    if (V.clearMaskOnLostFocus) {
                                        r = []
                                    } else {
                                        r = _().slice()
                                    }
                                }
                            }
                            B(n, r, se, t)
                        }
                        if (v !== C().join("")) {
                            v = r.join("");
                            i.trigger("change")
                        }
                    }
                },
                mouseenterEvent: function e(t) {
                    var i = this;
                    a = true;
                    if (le.activeElement !== i && V.showMaskOnHover) {
                        l(i, (g ? C().slice().reverse() : C()).join(""))
                    }
                },
                submitEvent: function e(t) {
                    if (v !== C().join("")) {
                        r.trigger("change")
                    }
                    if (V.clearMaskOnLostFocus && S() === -1 && u.inputmask._valueGet && u.inputmask._valueGet() === _().join("")) {
                        u.inputmask._valueSet("")
                    }
                    if (V.clearIncomplete && $(C()) === false) {
                        u.inputmask._valueSet("")
                    }
                    if (V.removeMaskOnSubmit) {
                        u.inputmask._valueSet(u.inputmask.unmaskedvalue(), true);
                        setTimeout(function() {
                            B(u, C())
                        }, 0)
                    }
                },
                resetEvent: function e(t) {
                    u.inputmask.refreshValue = true;
                    setTimeout(function() {
                        r.trigger("setvalue")
                    }, 0)
                }
            };

            function z(a, e, r, t, i) {
                var o = this || a.inputmask,
                    s = t.slice(),
                    l = "",
                    u = -1,
                    f = se;

                function c(e, t) {
                    var i = d(true, 0, false).slice(e, G(e)).join("").replace(/'/g, "").indexOf(t);
                    return i !== -1 && !R(e) && (A(e).match.nativeDef === t.charAt(0) || A(e).match.fn === null && A(e).match.nativeDef === "'" + t.charAt(0) || A(e).match.nativeDef === " " && (A(e + 1).match.nativeDef === t.charAt(0) || A(e + 1).match.fn === null && A(e + 1).match.nativeDef === "'" + t.charAt(0)))
                }
                P();
                if (!r && V.autoUnmask !== true) {
                    var n = _().slice(0, G(-1)).join(""),
                        p = s.join("").match(new RegExp("^" + de.escapeRegex(n), "g"));
                    if (p && p.length > 0) {
                        s.splice(0, p.length * n.length);
                        u = G(u)
                    }
                } else {
                    u = G(u)
                }
                if (u === -1) {
                    K().p = G(u);
                    u = 0
                } else K().p = u;
                o.caretPos = {
                    begin: u
                };
                re.each(s, function(e, t) {
                    if (t !== se) {
                        if (K().validPositions[e] === se && s[e] === L(e) && R(e, true) && F(e, s[e], true, se, se, true) === false) {
                            K().p++
                        } else {
                            var i = new re.Event("_checkval");
                            i.which = t.charCodeAt(0);
                            l += t;
                            var n = S(se, true);
                            if (!c(u, l)) {
                                f = U.keypressEvent.call(a, i, true, false, r, o.caretPos.begin);
                                if (f) {
                                    u = o.caretPos.begin + 1;
                                    l = ""
                                }
                            } else {
                                f = U.keypressEvent.call(a, i, true, false, r, n + 1)
                            }
                            if (f) {
                                B(se, C(), f.forwardPosition, i, false);
                                o.caretPos = {
                                    begin: f.forwardPosition,
                                    end: f.forwardPosition
                                }
                            }
                        }
                    }
                });
                if (e) B(a, C(), f ? f.forwardPosition : se, i || new re.Event("checkval"), i && i.type === "input")
            }

            function i(e) {
                if (e) {
                    if (e.inputmask === se) {
                        return e.value
                    }
                    if (e.inputmask && e.inputmask.refreshValue) {
                        U.setValueEvent.call(e)
                    }
                }
                var t = [],
                    i = K().validPositions;
                for (var n in i) {
                    if (i[n].match && i[n].match.fn != null) {
                        t.push(i[n].input)
                    }
                }
                var a = t.length === 0 ? "" : (g ? t.reverse() : t).join("");
                if (re.isFunction(V.onUnMask)) {
                    var r = (g ? C().slice().reverse() : C()).join("");
                    a = V.onUnMask.call(c, r, a, V)
                }
                return a
            }

            function W(e, t, i, n) {
                function a(e) {
                    if (g && typeof e === "number" && (!V.greedy || V.placeholder !== "") && u) {
                        e = u.inputmask._valueGet().length - e
                    }
                    return e
                }
                var r;
                if (t !== se) {
                    if (re.isArray(t)) {
                        i = g ? t[0] : t[1];
                        t = g ? t[1] : t[0]
                    }
                    if (t.begin !== se) {
                        i = g ? t.begin : t.end;
                        t = g ? t.end : t.begin
                    }
                    if (typeof t === "number") {
                        t = n ? t : a(t);
                        i = n ? i : a(i);
                        i = typeof i == "number" ? i : t;
                        var o = parseInt(((e.ownerDocument.defaultView || oe).getComputedStyle ? (e.ownerDocument.defaultView || oe).getComputedStyle(e, null) : e.currentStyle).fontSize) * i;
                        e.scrollLeft = o > e.scrollWidth ? o : 0;
                        e.inputmask.caretPos = {
                            begin: t,
                            end: i
                        };
                        if (e === le.activeElement) {
                            if ("selectionStart" in e) {
                                e.selectionStart = t;
                                e.selectionEnd = i
                            } else if (oe.getSelection) {
                                r = le.createRange();
                                if (e.firstChild === se || e.firstChild === null) {
                                    var s = le.createTextNode("");
                                    e.appendChild(s)
                                }
                                r.setStart(e.firstChild, t < e.inputmask._valueGet().length ? t : e.inputmask._valueGet().length);
                                r.setEnd(e.firstChild, i < e.inputmask._valueGet().length ? i : e.inputmask._valueGet().length);
                                r.collapse(true);
                                var l = oe.getSelection();
                                l.removeAllRanges();
                                l.addRange(r)
                            } else if (e.createTextRange) {
                                r = e.createTextRange();
                                r.collapse(true);
                                r.moveEnd("character", i);
                                r.moveStart("character", t);
                                r.select()
                            }
                            Y(e, {
                                begin: t,
                                end: i
                            })
                        }
                    }
                } else {
                    if ("selectionStart" in e) {
                        t = e.selectionStart;
                        i = e.selectionEnd
                    } else if (oe.getSelection) {
                        r = oe.getSelection().getRangeAt(0);
                        if (r.commonAncestorContainer.parentNode === e || r.commonAncestorContainer === e) {
                            t = r.startOffset;
                            i = r.endOffset
                        }
                    } else if (le.selection && le.selection.createRange) {
                        r = le.selection.createRange();
                        t = 0 - r.duplicate().moveStart("character", -e.inputmask._valueGet().length);
                        i = t + r.text.length
                    }
                    return {
                        begin: n ? t : a(t),
                        end: n ? i : a(i)
                    }
                }
            }

            function q(e) {
                var t = d(true, S(), true, true),
                    i = t.length,
                    n, a = S(),
                    r = {},
                    o = K().validPositions[a],
                    s = o !== se ? o.locator.slice() : se,
                    l;
                for (n = a + 1; n < t.length; n++) {
                    l = b(n, s, n - 1);
                    s = l.locator.slice();
                    r[n] = re.extend(true, {}, l)
                }
                var u = o && o.alternation !== se ? o.locator[o.alternation] : se;
                for (n = i - 1; n > a; n--) {
                    l = r[n];
                    if ((l.match.optionality || l.match.optionalQuantifier && l.match.newBlockMarker || u && (u !== r[n].locator[o.alternation] && l.match.fn != null || l.match.fn === null && l.locator[o.alternation] && O(l.locator[o.alternation].toString().split(","), u.toString().split(",")) && E(n)[0].def !== "")) && t[n] === L(n, l.match)) {
                        i--
                    } else break
                }
                return e ? {
                    l: i,
                    def: r[i] ? r[i].match : se
                } : i
            }

            function Q(e) {
                e.length = 0;
                var t = d(true, 0, true, se, true),
                    i, n;
                while (i = t.shift(), i !== se) {
                    e.push(i)
                }
                return e
            }

            function $(e) {
                if (re.isFunction(V.isComplete)) return V.isComplete(e, V);
                if (V.repeat === "*") return se;
                var t = false,
                    i = q(true),
                    n = I(i.l);
                if (i.def === se || i.def.newBlockMarker || i.def.optionality || i.def.optionalQuantifier) {
                    t = true;
                    for (var a = 0; a <= n; a++) {
                        var r = b(a).match;
                        if (r.fn !== null && K().validPositions[a] === se && r.optionality !== true && r.optionalQuantifier !== true || r.fn === null && e[a] !== L(a, r)) {
                            t = false;
                            break
                        }
                    }
                }
                return t
            }

            function Z(e, t, i, n, a) {
                if (V.numericInput || g) {
                    if (t === de.keyCode.BACKSPACE) {
                        t = de.keyCode.DELETE
                    } else if (t === de.keyCode.DELETE) {
                        t = de.keyCode.BACKSPACE
                    }
                    if (g) {
                        var r = i.end;
                        i.end = i.begin;
                        i.begin = r
                    }
                }
                if (t === de.keyCode.BACKSPACE && i.end - i.begin < 1) {
                    i.begin = I(i.begin);
                    if (K().validPositions[i.begin] !== se && K().validPositions[i.begin].input === V.groupSeparator) {
                        i.begin--
                    }
                } else if (t === de.keyCode.DELETE && i.begin === i.end) {
                    i.end = R(i.end, true) && K().validPositions[i.end] && K().validPositions[i.end].input !== V.radixPoint ? i.end + 1 : G(i.end) + 1;
                    if (K().validPositions[i.begin] !== se && K().validPositions[i.begin].input === V.groupSeparator) {
                        i.end++
                    }
                }
                N(i);
                if (n !== true && V.keepStatic !== false || V.regex !== null) {
                    var o = j(true);
                    if (o) {
                        var s = o.caret !== se ? o.caret : o.pos ? G(o.pos.begin ? o.pos.begin : o.pos) : S(-1, true);
                        if (t !== de.keyCode.DELETE || i.begin > s) {
                            i.begin == s
                        }
                    }
                }
                var l = S(i.begin, true);
                if (l < i.begin || i.begin === -1) {
                    K().p = G(l)
                } else if (n !== true) {
                    K().p = i.begin;
                    if (a !== true) {
                        while (K().p < l && K().validPositions[K().p] === se) {
                            K().p++
                        }
                    }
                }
            }

            function J(u) {
                var f = (u.ownerDocument.defaultView || oe).getComputedStyle(u, null);

                function t(e) {
                    var t = le.createElement("span"),
                        i;
                    for (var n in f) {
                        if (isNaN(n) && n.indexOf("font") !== -1) {
                            t.style[n] = f[n]
                        }
                    }
                    t.style.textTransform = f.textTransform;
                    t.style.letterSpacing = f.letterSpacing;
                    t.style.position = "absolute";
                    t.style.height = "auto";
                    t.style.width = "auto";
                    t.style.visibility = "hidden";
                    t.style.whiteSpace = "nowrap";
                    le.body.appendChild(t);
                    var a = u.inputmask._valueGet(),
                        r = 0,
                        o;
                    for (i = 0, o = a.length; i <= o; i++) {
                        t.innerHTML += a.charAt(i) || "_";
                        if (t.offsetWidth >= e) {
                            var s = e - r;
                            var l = t.offsetWidth - e;
                            t.innerHTML = a.charAt(i);
                            s -= t.offsetWidth / 3;
                            i = s < l ? i - 1 : i;
                            break
                        }
                        r = t.offsetWidth
                    }
                    le.body.removeChild(t);
                    return i
                }
                var e = le.createElement("div");
                e.style.width = f.width;
                e.style.textAlign = f.textAlign;
                m = le.createElement("div");
                u.inputmask.colorMask = m;
                m.className = "im-colormask";
                u.parentNode.insertBefore(m, u);
                u.parentNode.removeChild(u);
                m.appendChild(u);
                m.appendChild(e);
                u.style.left = e.offsetLeft + "px";
                re(m).on("mouseleave", function(e) {
                    return U.mouseleaveEvent.call(u, [e])
                });
                re(m).on("mouseenter", function(e) {
                    return U.mouseenterEvent.call(u, [e])
                });
                re(m).on("click", function(e) {
                    W(u, t(e.clientX));
                    return U.clickEvent.call(u, [e])
                })
            }

            function Y(e, t, i) {
                var n = [],
                    a = false,
                    r, o, s, l = 0;

                function u(e) {
                    if (e === se) e = "";
                    if (!a && (r.fn === null || o.input === se)) {
                        a = true;
                        n.push("<span class='im-static'>" + e)
                    } else if (a && (r.fn !== null && o.input !== se || r.def === "")) {
                        a = false;
                        var t = n.length;
                        n[t - 1] = n[t - 1] + "</span>";
                        n.push(e)
                    } else n.push(e)
                }

                function f() {
                    if (le.activeElement === e) {
                        n.splice(t.begin, 0, t.begin === t.end || t.end > K().maskLength ? '<mark class="im-caret" style="border-right-width: 1px;border-right-style: solid;">' : '<mark class="im-caret-select">');
                        n.splice(t.end + 1, 0, "</mark>")
                    }
                }
                if (m !== se) {
                    var c = C();
                    if (t === se) {
                        t = W(e)
                    } else if (t.begin === se) {
                        t = {
                            begin: t,
                            end: t
                        }
                    }
                    if (i !== true) {
                        var p = S();
                        do {
                            if (K().validPositions[l]) {
                                o = K().validPositions[l];
                                r = o.match;
                                s = o.locator.slice();
                                u(c[l])
                            } else {
                                o = b(l, s, l - 1);
                                r = o.match;
                                s = o.locator.slice();
                                if (V.jitMasking === false || l < p || typeof V.jitMasking === "number" && isFinite(V.jitMasking) && V.jitMasking > l) {
                                    u(L(l, r))
                                } else a = false
                            }
                            l++
                        } while ((k === se || l < k) && (r.fn !== null || r.def !== "") || p > l || a);
                        if (a) u();
                        f()
                    }
                    var d = m.getElementsByTagName("div")[0];
                    d.innerHTML = n.join("");
                    e.inputmask.positionColorMask(e, d)
                }
            }

            function n(e) {
                function t(e, l) {
                    function t(e) {
                        var t;
                        var i;

                        function n(e) {
                            if (re.valHooks && (re.valHooks[e] === se || re.valHooks[e].inputmaskpatch !== true)) {
                                var n = re.valHooks[e] && re.valHooks[e].get ? re.valHooks[e].get : function(e) {
                                    return e.value
                                };
                                var r = re.valHooks[e] && re.valHooks[e].set ? re.valHooks[e].set : function(e, t) {
                                    e.value = t;
                                    return e
                                };
                                re.valHooks[e] = {
                                    get: function e(t) {
                                        if (t.inputmask) {
                                            if (t.inputmask.opts.autoUnmask) {
                                                return t.inputmask.unmaskedvalue()
                                            } else {
                                                var i = n(t);
                                                return S(se, se, t.inputmask.maskset.validPositions) !== -1 || l.nullable !== true ? i : ""
                                            }
                                        } else return n(t)
                                    },
                                    set: function e(t, i) {
                                        var n = re(t),
                                            a;
                                        a = r(t, i);
                                        if (t.inputmask) {
                                            n.trigger("setvalue", [i])
                                        }
                                        return a
                                    },
                                    inputmaskpatch: true
                                }
                            }
                        }

                        function a() {
                            if (this.inputmask) {
                                return this.inputmask.opts.autoUnmask ? this.inputmask.unmaskedvalue() : S() !== -1 || l.nullable !== true ? le.activeElement === this && l.clearMaskOnLostFocus ? (g ? Q(C().slice()).reverse() : Q(C().slice())).join("") : t.call(this) : ""
                            } else return t.call(this)
                        }

                        function r(e) {
                            i.call(this, e);
                            if (this.inputmask) {
                                re(this).trigger("setvalue", [e])
                            }
                        }

                        function o(e) {
                            H.on(e, "mouseenter", function(e) {
                                var t = re(this),
                                    i = this,
                                    n = i.inputmask._valueGet();
                                if (n !== C().join("")) {
                                    t.trigger("setvalue")
                                }
                            })
                        }
                        if (!e.inputmask.__valueGet) {
                            if (l.noValuePatching !== true) {
                                if (Object.getOwnPropertyDescriptor) {
                                    if (typeof Object.getPrototypeOf !== "function") {
                                        Object.getPrototypeOf = ge("test".__proto__) === "object" ? function(e) {
                                            return e.__proto__
                                        } : function(e) {
                                            return e.constructor.prototype
                                        }
                                    }
                                    var s = Object.getPrototypeOf ? Object.getOwnPropertyDescriptor(Object.getPrototypeOf(e), "value") : se;
                                    if (s && s.get && s.set) {
                                        t = s.get;
                                        i = s.set;
                                        Object.defineProperty(e, "value", {
                                            get: a,
                                            set: r,
                                            configurable: true
                                        })
                                    } else if (e.tagName !== "INPUT") {
                                        t = function e() {
                                            return this.textContent
                                        };
                                        i = function e(t) {
                                            this.textContent = t
                                        };
                                        Object.defineProperty(e, "value", {
                                            get: a,
                                            set: r,
                                            configurable: true
                                        })
                                    }
                                } else if (le.__lookupGetter__ && e.__lookupGetter__("value")) {
                                    t = e.__lookupGetter__("value");
                                    i = e.__lookupSetter__("value");
                                    e.__defineGetter__("value", a);
                                    e.__defineSetter__("value", r)
                                }
                                e.inputmask.__valueGet = t;
                                e.inputmask.__valueSet = i
                            }
                            e.inputmask._valueGet = function(e) {
                                return g && e !== true ? t.call(this.el).split("").reverse().join("") : t.call(this.el)
                            };
                            e.inputmask._valueSet = function(e, t) {
                                i.call(this.el, e === null || e === se ? "" : t !== true && g ? e.split("").reverse().join("") : e)
                            };
                            if (t === se) {
                                t = function e() {
                                    return this.value
                                };
                                i = function e(t) {
                                    this.value = t
                                };
                                n(e.type);
                                o(e)
                            }
                        }
                    }
                    var i = e.getAttribute("type");
                    var n = e.tagName === "INPUT" && re.inArray(i, l.supportsInputType) !== -1 || e.isContentEditable || e.tagName === "TEXTAREA";
                    if (!n) {
                        if (e.tagName === "INPUT") {
                            var a = le.createElement("input");
                            a.setAttribute("type", i);
                            n = a.type === "text";
                            a = null
                        } else n = "partial"
                    }
                    if (n !== false) {
                        t(e)
                    } else e.inputmask = se;
                    return n
                }
                H.off(e);
                var i = t(e, V);
                if (i !== false) {
                    u = e;
                    r = re(u);
                    o = u.placeholder;
                    k = u !== se ? u.maxLength : se;
                    if (k === -1) k = se;
                    if (V.colorMask === true) {
                        J(u)
                    }
                    if (fe) {
                        if ("inputMode" in u) {
                            u.inputmode = V.inputmode;
                            u.setAttribute("inputmode", V.inputmode)
                        }
                        if (V.disablePredictiveText === true) {
                            if ("autocorrect" in u) {
                                u.autocorrect = false
                            } else {
                                if (V.colorMask !== true) {
                                    J(u)
                                }
                                u.type = "password"
                            }
                        }
                    }
                    if (i === true) {
                        u.setAttribute("im-insert", V.insertMode);
                        H.on(u, "submit", U.submitEvent);
                        H.on(u, "reset", U.resetEvent);
                        H.on(u, "blur", U.blurEvent);
                        H.on(u, "focus", U.focusEvent);
                        if (V.colorMask !== true) {
                            H.on(u, "click", U.clickEvent);
                            H.on(u, "mouseleave", U.mouseleaveEvent);
                            H.on(u, "mouseenter", U.mouseenterEvent)
                        }
                        H.on(u, "paste", U.pasteEvent);
                        H.on(u, "cut", U.cutEvent);
                        H.on(u, "complete", V.oncomplete);
                        H.on(u, "incomplete", V.onincomplete);
                        H.on(u, "cleared", V.oncleared);
                        if (!fe && V.inputEventOnly !== true) {
                            H.on(u, "keydown", U.keydownEvent);
                            H.on(u, "keypress", U.keypressEvent)
                        } else {
                            u.removeAttribute("maxLength")
                        }
                        H.on(u, "input", U.inputFallBackEvent);
                        H.on(u, "beforeinput", U.beforeInputEvent)
                    }
                    H.on(u, "setvalue", U.setValueEvent);
                    v = _().join("");
                    if (u.inputmask._valueGet(true) !== "" || V.clearMaskOnLostFocus === false || le.activeElement === u) {
                        var n = re.isFunction(V.onBeforeMask) ? V.onBeforeMask.call(c, u.inputmask._valueGet(true), V) || u.inputmask._valueGet(true) : u.inputmask._valueGet(true);
                        if (n !== "") z(u, true, false, n.split(""));
                        var a = C().slice();
                        v = a.join("");
                        if ($(a) === false) {
                            if (V.clearIncomplete) {
                                P()
                            }
                        }
                        if (V.clearMaskOnLostFocus && le.activeElement !== u) {
                            if (S() === -1) {
                                a = []
                            } else {
                                Q(a)
                            }
                        }
                        if (V.clearMaskOnLostFocus === false || V.showMaskOnFocus && le.activeElement === u || u.inputmask._valueGet(true) !== "") B(u, a);
                        if (le.activeElement === u) {
                            W(u, G(S()))
                        }
                    }
                }
            }
            var X;
            if (e !== se) {
                switch (e.action) {
                    case "isComplete":
                        u = e.el;
                        return $(C());
                    case "unmaskedvalue":
                        if (u === se || e.value !== se) {
                            X = e.value;
                            X = (re.isFunction(V.onBeforeMask) ? V.onBeforeMask.call(c, X, V) || X : X).split("");
                            z.call(this, se, false, false, X);
                            if (re.isFunction(V.onBeforeWrite)) V.onBeforeWrite.call(c, se, C(), 0, V)
                        }
                        return i(u);
                    case "mask":
                        n(u);
                        break;
                    case "format":
                        X = (re.isFunction(V.onBeforeMask) ? V.onBeforeMask.call(c, e.value, V) || e.value : e.value).split("");
                        z.call(this, se, true, false, X);
                        if (e.metadata) {
                            return {
                                value: g ? C().slice().reverse().join("") : C().join(""),
                                metadata: he.call(this, {
                                    action: "getmetadata"
                                }, t, V)
                            }
                        }
                        return g ? C().slice().reverse().join("") : C().join("");
                    case "isValid":
                        if (e.value) {
                            X = e.value.split("");
                            z.call(this, se, true, true, X)
                        } else {
                            e.value = C().join("")
                        }
                        var ee = C();
                        var te = q(),
                            ie = ee.length - 1;
                        for (; ie > te; ie--) {
                            if (R(ie)) break
                        }
                        ee.splice(te, ie + 1 - te);
                        return $(ee) && e.value === C().join("");
                    case "getemptymask":
                        return _().join("");
                    case "remove":
                        if (u && u.inputmask) {
                            re.data(u, "_inputmask_opts", null);
                            r = re(u);
                            u.inputmask._valueSet(V.autoUnmask ? i(u) : u.inputmask._valueGet(true));
                            H.off(u);
                            if (u.inputmask.colorMask) {
                                m = u.inputmask.colorMask;
                                m.removeChild(u);
                                m.parentNode.insertBefore(u, m);
                                m.parentNode.removeChild(m)
                            }
                            var ne;
                            if (Object.getOwnPropertyDescriptor && Object.getPrototypeOf) {
                                ne = Object.getOwnPropertyDescriptor(Object.getPrototypeOf(u), "value");
                                if (ne) {
                                    if (u.inputmask.__valueGet) {
                                        Object.defineProperty(u, "value", {
                                            get: u.inputmask.__valueGet,
                                            set: u.inputmask.__valueSet,
                                            configurable: true
                                        })
                                    }
                                }
                            } else if (le.__lookupGetter__ && u.__lookupGetter__("value")) {
                                if (u.inputmask.__valueGet) {
                                    u.__defineGetter__("value", u.inputmask.__valueGet);
                                    u.__defineSetter__("value", u.inputmask.__valueSet)
                                }
                            }
                            u.inputmask = se
                        }
                        return u;
                        break;
                    case "getmetadata":
                        if (re.isArray(t.metadata)) {
                            var ae = d(true, 0, false).join("");
                            re.each(t.metadata, function(e, t) {
                                if (t.mask === ae) {
                                    ae = t;
                                    return false
                                }
                            });
                            return ae
                        }
                        return t.metadata
                }
            }
        }
        return de.prototype = {
            dataAttribute: "data-inputmask",
            defaults: {
                placeholder: "_",
                optionalmarker: ["[", "]"],
                quantifiermarker: ["{", "}"],
                groupmarker: ["(", ")"],
                alternatormarker: "|",
                escapeChar: "\\",
                mask: null,
                regex: null,
                oncomplete: re.noop,
                onincomplete: re.noop,
                oncleared: re.noop,
                repeat: 0,
                greedy: !1,
                autoUnmask: !1,
                removeMaskOnSubmit: !1,
                clearMaskOnLostFocus: !0,
                insertMode: !0,
                clearIncomplete: !1,
                alias: null,
                onKeyDown: re.noop,
                onBeforeMask: null,
                onBeforePaste: function(e, t) {
                    return re.isFunction(t.onBeforeMask) ? t.onBeforeMask.call(this, e, t) : e
                },
                onBeforeWrite: null,
                onUnMask: null,
                showMaskOnFocus: !0,
                showMaskOnHover: !0,
                onKeyValidation: re.noop,
                skipOptionalPartCharacter: " ",
                numericInput: !1,
                rightAlign: !1,
                undoOnEscape: !0,
                radixPoint: "",
                _radixDance: !1,
                groupSeparator: "",
                keepStatic: null,
                positionCaretOnTab: !0,
                tabThrough: !1,
                supportsInputType: ["text", "tel", "url", "password", "search"],
                ignorables: [8, 9, 13, 19, 27, 33, 34, 35, 36, 37, 38, 39, 40, 45, 46, 93, 112, 113, 114, 115, 116, 117, 118, 119, 120, 121, 122, 123, 0, 229],
                isComplete: null,
                preValidation: null,
                postValidation: null,
                staticDefinitionSymbol: se,
                jitMasking: !1,
                nullable: !0,
                inputEventOnly: !1,
                noValuePatching: !1,
                positionCaretOnClick: "lvp",
                casing: null,
                inputmode: "verbatim",
                colorMask: !1,
                disablePredictiveText: !1,
                importDataAttributes: !0,
                shiftPositions: !0
            },
            definitions: {
                9: {
                    validator: "[0-9１-９]",
                    definitionSymbol: "*"
                },
                a: {
                    validator: "[A-Za-zА-яЁёÀ-ÿµ]",
                    definitionSymbol: "*"
                },
                "*": {
                    validator: "[0-9１-９A-Za-zА-яЁёÀ-ÿµ]"
                }
            },
            aliases: {},
            masksCache: {},
            mask: function(e) {
                var a = this;
                return "string" == typeof e && (e = le.getElementById(e) || le.querySelectorAll(e)), e = e.nodeName ? [e] : e, re.each(e, function(e, t) {
                    var i, n = re.extend(!0, {}, a.opts);
                    ! function(i, e, n, a) {
                        if (!0 === e.importDataAttributes) {
                            var t, r, o, s, l = i.getAttribute(a),
                                u = function(e, t) {
                                    null !== (t = t !== se ? t : i.getAttribute(a + "-" + e)) && ("string" == typeof t && (0 === e.indexOf("on") ? t = oe[t] : "false" === t ? t = !1 : "true" === t && (t = !0)), n[e] = t)
                                };
                            if (l && "" !== l && (l = l.replace(/'/g, '"'), r = JSON.parse("{" + l + "}")), r)
                                for (s in o = se, r)
                                    if ("alias" === s.toLowerCase()) {
                                        o = r[s];
                                        break
                                    } for (t in u("alias", o), n.alias && f(n.alias, n, e), e) {
                                if (r)
                                    for (s in o = se, r)
                                        if (s.toLowerCase() === t.toLowerCase()) {
                                            o = r[s];
                                            break
                                        } u(t, o)
                            }
                        }
                        return re.extend(!0, e, n), "rtl" !== i.dir && !e.rightAlign || (i.style.textAlign = "right"), "rtl" !== i.dir && !e.numericInput || (i.dir = "ltr", i.removeAttribute("dir"), e.isRTL = !0), Object.keys(n).length
                    }(t, n, re.extend(!0, {}, a.userOptions), a.dataAttribute) || (i = r(n, a.noMasksCache)) !== se && (t.inputmask !== se && (t.inputmask.opts.autoUnmask = !0, t.inputmask.remove()), t.inputmask = new de(se, se, !0), t.inputmask.opts = n, t.inputmask.noMasksCache = a.noMasksCache, t.inputmask.userOptions = re.extend(!0, {}, a.userOptions), t.inputmask.isRTL = n.isRTL || n.numericInput, (t.inputmask.el = t).inputmask.maskset = i, re.data(t, "_inputmask_opts", n), he.call(t.inputmask, {
                        action: "mask"
                    }))
                }), e && e[0] && e[0].inputmask || this
            },
            option: function(e, t) {
                return "string" == typeof e ? this.opts[e] : "object" === (void 0 === e ? "undefined" : ge(e)) ? (re.extend(this.userOptions, e), this.el && !0 !== t && this.mask(this.el), this) : void 0
            },
            unmaskedvalue: function(e) {
                return this.maskset = this.maskset || r(this.opts, this.noMasksCache), he.call(this, {
                    action: "unmaskedvalue",
                    value: e
                })
            },
            remove: function() {
                return he.call(this, {
                    action: "remove"
                })
            },
            getemptymask: function() {
                return this.maskset = this.maskset || r(this.opts, this.noMasksCache), he.call(this, {
                    action: "getemptymask"
                })
            },
            hasMaskedValue: function() {
                return !this.opts.autoUnmask
            },
            isComplete: function() {
                return this.maskset = this.maskset || r(this.opts, this.noMasksCache), he.call(this, {
                    action: "isComplete"
                })
            },
            getmetadata: function() {
                return this.maskset = this.maskset || r(this.opts, this.noMasksCache), he.call(this, {
                    action: "getmetadata"
                })
            },
            isValid: function(e) {
                return this.maskset = this.maskset || r(this.opts, this.noMasksCache), he.call(this, {
                    action: "isValid",
                    value: e
                })
            },
            format: function(e, t) {
                return this.maskset = this.maskset || r(this.opts, this.noMasksCache), he.call(this, {
                    action: "format",
                    value: e,
                    metadata: t
                })
            },
            setValue: function(e) {
                this.el && re(this.el).trigger("setvalue", [e])
            },
            analyseMask: function(e, r, o) {
                var t, i, n, a = /(?:[?*+]|\{[0-9\+\*]+(?:,[0-9\+\*]*)?(?:\|[0-9\+\*]*)?\})|[^.?*+^${[]()|\\]+|./g,
                    s = /\[\^?]?(?:[^\\\]]+|\\[\S\s]?)*]?|\\(?:0(?:[0-3][0-7]{0,2}|[4-7][0-7]?)?|[1-9][0-9]*|x[0-9A-Fa-f]{2}|u[0-9A-Fa-f]{4}|c[A-Za-z]|[\S\s]?)|\((?:\?[:=!]?)?|(?:[?*+]|\{[0-9]+(?:,[0-9]*)?\})\??|[^.?*+^${[()|\\]+|./g,
                    l = !1,
                    u = new p,
                    f = [],
                    c = [];

                function p(e, t, i, n) {
                    this.matches = [], this.openGroup = e || !1, this.alternatorGroup = !1, this.isGroup = e || !1, this.isOptional = t || !1, this.isQuantifier = i || !1, this.isAlternator = n || !1, this.quantifier = {
                        min: 1,
                        max: 1
                    }
                }

                function d(i, e, n) {
                    n = n !== se ? n : i.matches.length;
                    var t, a = i.matches[n - 1];
                    r ? (0 === e.indexOf("[") || l && /\\d|\\s|\\w]/i.test(e) || "." === e ? i.matches.splice(n++, 0, {
                        fn: new RegExp(e, o.casing ? "i" : ""),
                        optionality: !1,
                        newBlockMarker: a === se ? "master" : a.def !== e,
                        casing: null,
                        def: e,
                        placeholder: se,
                        nativeDef: e
                    }) : (l && (e = e[e.length - 1]), re.each(e.split(""), function(e, t) {
                        a = i.matches[n - 1], i.matches.splice(n++, 0, {
                            fn: null,
                            optionality: !1,
                            newBlockMarker: a === se ? "master" : a.def !== t && null !== a.fn,
                            casing: null,
                            def: o.staticDefinitionSymbol || t,
                            placeholder: o.staticDefinitionSymbol !== se ? t : se,
                            nativeDef: (l ? "'" : "") + t
                        })
                    })), l = !1) : (t = (o.definitions ? o.definitions[e] : se) || de.prototype.definitions[e]) && !l ? i.matches.splice(n++, 0, {
                        fn: t.validator ? "string" == typeof t.validator ? new RegExp(t.validator, o.casing ? "i" : "") : new function() {
                            this.test = t.validator
                        } : new RegExp("."),
                        optionality: !1,
                        newBlockMarker: a === se ? "master" : a.def !== (t.definitionSymbol || e),
                        casing: t.casing,
                        def: t.definitionSymbol || e,
                        placeholder: t.placeholder,
                        nativeDef: e
                    }) : (i.matches.splice(n++, 0, {
                        fn: null,
                        optionality: !1,
                        newBlockMarker: a === se ? "master" : a.def !== e && null !== a.fn,
                        casing: null,
                        def: o.staticDefinitionSymbol || e,
                        placeholder: o.staticDefinitionSymbol !== se ? e : se,
                        nativeDef: (l ? "'" : "") + e
                    }), l = !1)
                }

                function m() {
                    if (0 < f.length) {
                        if (d(i = f[f.length - 1], v), i.isAlternator) {
                            n = f.pop();
                            for (var e = 0; e < n.matches.length; e++) n.matches[e].isGroup && (n.matches[e].isGroup = !1);
                            0 < f.length ? (i = f[f.length - 1]).matches.push(n) : u.matches.push(n)
                        }
                    } else d(u, v)
                }

                function h(e) {
                    var t = new p(!0);
                    return t.openGroup = !1, t.matches = e, t
                }
                for (r && (o.optionalmarker[0] = se, o.optionalmarker[1] = se); A = r ? s.exec(e) : a.exec(e);) {
                    if (v = A[0], r) switch (v.charAt(0)) {
                        case "?":
                            v = "{0,1}";
                            break;
                        case "+":
                        case "*":
                            v = "{" + v + "}"
                    }
                    if (l) m();
                    else switch (v.charAt(0)) {
                        case "(?=":
                        case "(?!":
                        case "(?<=":
                        case "(?<!":
                            break;
                        case o.escapeChar:
                            l = !0, r && m();
                            break;
                        case o.optionalmarker[1]:
                        case o.groupmarker[1]:
                            if ((t = f.pop()).openGroup = !1, t !== se)
                                if (0 < f.length) {
                                    if ((i = f[f.length - 1]).matches.push(t), i.isAlternator) {
                                        n = f.pop();
                                        for (var g = 0; g < n.matches.length; g++) n.matches[g].isGroup = !1, n.matches[g].alternatorGroup = !1;
                                        0 < f.length ? (i = f[f.length - 1]).matches.push(n) : u.matches.push(n)
                                    }
                                } else u.matches.push(t);
                            else m();
                            break;
                        case o.optionalmarker[0]:
                            f.push(new p(!1, !0));
                            break;
                        case o.groupmarker[0]:
                            f.push(new p(!0));
                            break;
                        case o.quantifiermarker[0]:
                            var v, k = new p(!1, !1, !0),
                                y = (v = v.replace(/[{}]/g, "")).split("|"),
                                b = y[0].split(","),
                                x = isNaN(b[0]) ? b[0] : parseInt(b[0]),
                                P = 1 === b.length ? x : isNaN(b[1]) ? b[1] : parseInt(b[1]);
                            "*" !== x && "+" !== x || (x = "*" === P ? 0 : 1), k.quantifier = {
                                min: x,
                                max: P,
                                jit: y[1]
                            };
                            var S, w, A, E = 0 < f.length ? f[f.length - 1].matches : u.matches;
                            (A = E.pop()).isAlternator && (E.push(A), E = A.matches, S = new p(!0), w = E.pop(), E.push(S), E = S.matches, A = w), A.isGroup || (A = h([A])), E.push(A), E.push(k);
                            break;
                        case o.alternatormarker:
                            var _, C, D, M = function(e) {
                                var t = e.pop();
                                return t.isQuantifier && (t = h([e.pop(), t])), t
                            };
                            (C = 0 < f.length ? (_ = (i = f[f.length - 1]).matches[i.matches.length - 1], i.openGroup && (_.matches === se || !1 === _.isGroup && !1 === _.isAlternator) ? f.pop() : M(i.matches)) : M(u.matches)).isAlternator ? f.push(C) : (C.alternatorGroup ? (n = f.pop(), C.alternatorGroup = !1) : n = new p(!1, !1, !1, !0), n.matches.push(C), f.push(n), C.openGroup && ((D = new p(!(C.openGroup = !1))).alternatorGroup = !0, f.push(D)));
                            break;
                        default:
                            m()
                    }
                }
                for (; 0 < f.length;) t = f.pop(), u.matches.push(t);
                return 0 < u.matches.length && (function n(a) {
                    a && a.matches && re.each(a.matches, function(e, t) {
                        var i = a.matches[e + 1];
                        (i === se || i.matches === se || !1 === i.isQuantifier) && t && t.isGroup && (t.isGroup = !1, r || (d(t, o.groupmarker[0], 0), !0 !== t.openGroup && d(t, o.groupmarker[1]))), n(t)
                    })
                }(u), c.push(u)), (o.numericInput || o.isRTL) && function e(t) {
                    for (var i in t.matches = t.matches.reverse(), t.matches) {
                        var n, a;
                        t.matches.hasOwnProperty(i) && (n = parseInt(i), t.matches[i].isQuantifier && t.matches[n + 1] && t.matches[n + 1].isGroup && (a = t.matches[i], t.matches.splice(i, 1), t.matches.splice(n + 1, 0, a)), t.matches[i].matches !== se ? t.matches[i] = e(t.matches[i]) : t.matches[i] = ((r = t.matches[i]) === o.optionalmarker[0] ? r = o.optionalmarker[1] : r === o.optionalmarker[1] ? r = o.optionalmarker[0] : r === o.groupmarker[0] ? r = o.groupmarker[1] : r === o.groupmarker[1] && (r = o.groupmarker[0]), r))
                    }
                    var r;
                    return t
                }(c[0]), c
            },
            positionColorMask: function(e, t) {
                e.style.left = t.offsetLeft + "px"
            }
        }, de.extendDefaults = function(e) {
            re.extend(!0, de.prototype.defaults, e)
        }, de.extendDefinitions = function(e) {
            re.extend(!0, de.prototype.definitions, e)
        }, de.extendAliases = function(e) {
            re.extend(!0, de.prototype.aliases, e)
        }, de.format = function(e, t, i) {
            return de(t).format(e, i)
        }, de.unmask = function(e, t) {
            return de(t).unmaskedvalue(e)
        }, de.isValid = function(e, t) {
            return de(t).isValid(e)
        }, de.remove = function(e) {
            "string" == typeof e && (e = le.getElementById(e) || le.querySelectorAll(e)), e = e.nodeName ? [e] : e, re.each(e, function(e, t) {
                t.inputmask && t.inputmask.remove()
            })
        }, de.setValue = function(e, i) {
            "string" == typeof e && (e = le.getElementById(e) || le.querySelectorAll(e)), e = e.nodeName ? [e] : e, re.each(e, function(e, t) {
                t.inputmask ? t.inputmask.setValue(i) : re(t).trigger("setvalue", [i])
            })
        }, de.escapeRegex = function(e) {
            return e.replace(new RegExp("(\\" + ["/", ".", "*", "+", "?", "|", "(", ")", "[", "]", "{", "}", "\\", "$", "^"].join("|\\") + ")", "gim"), "\\$1")
        }, de.keyCode = {
            BACKSPACE: 8,
            BACKSPACE_SAFARI: 127,
            DELETE: 46,
            DOWN: 40,
            END: 35,
            ENTER: 13,
            ESCAPE: 27,
            HOME: 36,
            INSERT: 45,
            LEFT: 37,
            PAGE_DOWN: 34,
            PAGE_UP: 33,
            RIGHT: 39,
            SPACE: 32,
            TAB: 9,
            UP: 38,
            X: 88,
            CONTROL: 17
        }, de.dependencyLib = re, de
    }) ? n.apply(t, a) : n) || (e.exports = r)
}, function(e, t, i) {
    "use strict";
    var n, a, r;
    a = [i(4)], void 0 === (r = "function" == typeof(n = function(e) {
        return e
    }) ? n.apply(t, a) : n) || (e.exports = r)
}, function(e, t) {
    e.exports = jQuery
}, function(module, exports, __webpack_require__) {
    "use strict";
    var __WEBPACK_AMD_DEFINE_RESULT__, _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(e) {
            return typeof e
        } : function(e) {
            return e && "function" == typeof Symbol && e.constructor === Symbol && e !== Symbol.prototype ? "symbol" : typeof e
        },
        __WEBPACK_AMD_DEFINE_RESULT__ = function() {
            return "undefined" != typeof window ? window : new(eval("require('jsdom').JSDOM"))("").window
        }.call(exports, __webpack_require__, exports, module);
    void 0 === __WEBPACK_AMD_DEFINE_RESULT__ || (module.exports = __WEBPACK_AMD_DEFINE_RESULT__)
}, function(e, t, i) {
    "use strict";
    var n, a, r, m = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(e) {
        return typeof e
    } : function(e) {
        return e && "function" == typeof Symbol && e.constructor === Symbol && e !== Symbol.prototype ? "symbol" : typeof e
    };
    a = [i(2)], void 0 === (r = "function" == typeof(n = function(s) {
        var l = s.dependencyLib,
            p = {
                d: ["[1-9]|[12][0-9]|3[01]", Date.prototype.setDate, "day", Date.prototype.getDate],
                dd: ["0[1-9]|[12][0-9]|3[01]", Date.prototype.setDate, "day", function() {
                    return f(Date.prototype.getDate.call(this), 2)
                }],
                ddd: [""],
                dddd: [""],
                m: ["[1-9]|1[012]", Date.prototype.setMonth, "month", function() {
                    return Date.prototype.getMonth.call(this) + 1
                }],
                mm: ["0[1-9]|1[012]", Date.prototype.setMonth, "month", function() {
                    return f(Date.prototype.getMonth.call(this) + 1, 2)
                }],
                mmm: [""],
                mmmm: [""],
                yy: ["[0-9]{2}", Date.prototype.setFullYear, "year", function() {
                    return f(Date.prototype.getFullYear.call(this), 2)
                }],
                yyyy: ["[0-9]{4}", Date.prototype.setFullYear, "year", function() {
                    return f(Date.prototype.getFullYear.call(this), 4)
                }],
                h: ["[1-9]|1[0-2]", Date.prototype.setHours, "hours", Date.prototype.getHours],
                hh: ["0[1-9]|1[0-2]", Date.prototype.setHours, "hours", function() {
                    return f(Date.prototype.getHours.call(this), 2)
                }],
                hhh: ["[0-9]+", Date.prototype.setHours, "hours", Date.prototype.getHours],
                H: ["1?[0-9]|2[0-3]", Date.prototype.setHours, "hours", Date.prototype.getHours],
                HH: ["0[0-9]|1[0-9]|2[0-3]", Date.prototype.setHours, "hours", function() {
                    return f(Date.prototype.getHours.call(this), 2)
                }],
                HHH: ["[0-9]+", Date.prototype.setHours, "hours", Date.prototype.getHours],
                M: ["[1-5]?[0-9]", Date.prototype.setMinutes, "minutes", Date.prototype.getMinutes],
                MM: ["0[0-9]|1[0-9]|2[0-9]|3[0-9]|4[0-9]|5[0-9]", Date.prototype.setMinutes, "minutes", function() {
                    return f(Date.prototype.getMinutes.call(this), 2)
                }],
                ss: ["[0-5][0-9]", Date.prototype.setSeconds, "seconds", function() {
                    return f(Date.prototype.getSeconds.call(this), 2)
                }],
                l: ["[0-9]{3}", Date.prototype.setMilliseconds, "milliseconds", function() {
                    return f(Date.prototype.getMilliseconds.call(this), 3)
                }],
                L: ["[0-9]{2}", Date.prototype.setMilliseconds, "milliseconds", function() {
                    return f(Date.prototype.getMilliseconds.call(this), 2)
                }],
                t: ["[ap]"],
                tt: ["[ap]m"],
                T: ["[AP]"],
                TT: ["[AP]M"],
                Z: [""],
                o: [""],
                S: [""]
            },
            t = {
                isoDate: "yyyy-mm-dd",
                isoTime: "HH:MM:ss",
                isoDateTime: "yyyy-mm-dd'T'HH:MM:ss",
                isoUtcDateTime: "UTC:yyyy-mm-dd'T'HH:MM:ss'Z'"
            };

        function d(e) {
            if (!e.tokenizer) {
                var t = [];
                for (var i in p) {
                    if (t.indexOf(i[0]) === -1) t.push(i[0])
                }
                e.tokenizer = "(" + t.join("+|") + ")+?|.";
                e.tokenizer = new RegExp(e.tokenizer, "g")
            }
            return e.tokenizer
        }

        function e(e, t) {
            return (!isFinite(e.rawday) || "29" == e.day && !isFinite(e.rawyear) || new Date(e.date.getFullYear(), isFinite(e.rawmonth) ? e.month : e.date.getMonth() + 1, 0).getDate() >= e.day) && t
        }

        function i(e, t) {
            var i = !0;
            if (t.min) {
                var n, a;
                e.rawyear && (n = e.rawyear.replace(/[^0-9]/g, ""), a = t.min.year.substr(0, n.length), i = a <= n), e.year === e.rawyear && t.min.date.getTime() == t.min.date.getTime() && (i = t.min.date.getTime() <= e.date.getTime())
            }
            if (i && t.max && t.max.date.getTime() == t.max.date.getTime()) i = t.max.date.getTime() >= e.date.getTime();
            return i
        }

        function u(e, t, i, n) {
            var a = "",
                r;
            while (r = d(i).exec(e)) {
                if (t === undefined) {
                    if (p[r[0]]) {
                        a += "(" + p[r[0]][0] + ")"
                    } else {
                        switch (r[0]) {
                            case "[":
                                a += "(";
                                break;
                            case "]":
                                a += ")?";
                                break;
                            default:
                                a += s.escapeRegex(r[0])
                        }
                    }
                } else {
                    if (p[r[0]]) {
                        if (n !== true && p[r[0]][3]) {
                            var o = p[r[0]][3];
                            a += o.call(t.date)
                        } else if (p[r[0]][2]) a += t["raw" + p[r[0]][2]];
                        else a += r[0]
                    } else a += r[0]
                }
            }
            return a
        }

        function f(e, t) {
            e = String(e);
            t = t || 2;
            while (e.length < t) {
                e = "0" + e
            }
            return e
        }

        function c(e, t, r) {
            var i = {
                    date: new Date(1, 0, 1)
                },
                o, n = e,
                a, s, l;

            function u(e) {
                var t = e.replace(/[^0-9]/g, "0");
                if (t != e) {
                    var i = e.replace(/[^0-9]/g, ""),
                        n = (r.min && r.min[o] || e).toString(),
                        a = (r.max && r.max[o] || e).toString();
                    t = i + (i < n.slice(0, i.length) ? n.slice(i.length) : i > a.slice(0, i.length) ? a.slice(i.length) : t.toString().slice(i.length))
                }
                return t
            }

            function f(e, t, i) {
                e[o] = u(t);
                e["raw" + o] = t;
                if (s !== undefined) s.call(e.date, o == "month" ? parseInt(e[o]) - 1 : e[o])
            }
            if (typeof n === "string") {
                while (a = d(r).exec(t)) {
                    var c = n.slice(0, a[0].length);
                    if (p.hasOwnProperty(a[0])) {
                        l = p[a[0]][0];
                        o = p[a[0]][2];
                        s = p[a[0]][1];
                        f(i, c, r)
                    }
                    n = n.slice(c.length)
                }
                return i
            } else if (n && (typeof n === "undefined" ? "undefined" : m(n)) === "object" && n.hasOwnProperty("date")) {
                return n
            }
            return undefined
        }
        return s.extendAliases({
            datetime: {
                mask: function(e) {
                    return p.S = e.i18n.ordinalSuffix.join("|"), e.inputFormat = t[e.inputFormat] || e.inputFormat, e.displayFormat = t[e.displayFormat] || e.displayFormat || e.inputFormat, e.outputFormat = t[e.outputFormat] || e.outputFormat || e.inputFormat, e.placeholder = "" !== e.placeholder ? e.placeholder : e.inputFormat.replace(/[\[\]]/, ""), e.regex = u(e.inputFormat, void 0, e), null
                },
                placeholder: "",
                inputFormat: "isoDateTime",
                displayFormat: void 0,
                outputFormat: void 0,
                min: null,
                max: null,
                i18n: {
                    dayNames: ["Mon", "Tue", "Wed", "Thu", "Fri", "Sat", "Sun", "Monday", "Tuesday", "Wednesday", "Thursday", "Friday", "Saturday", "Sunday"],
                    monthNames: ["Jan", "Feb", "Mar", "Apr", "May", "Jun", "Jul", "Aug", "Sep", "Oct", "Nov", "Dec", "January", "February", "March", "April", "May", "June", "July", "August", "September", "October", "November", "December"],
                    ordinalSuffix: ["st", "nd", "rd", "th"]
                },
                postValidation: function(e, t, i, n) {
                    n.min = c(n.min, n.inputFormat, n), n.max = c(n.max, n.inputFormat, n);
                    var a, r, o = i,
                        s = c(e.join(""), n.inputFormat, n);
                    return o && s.date.getTime() == s.date.getTime() && (a = s, r = o, o = (o = (!isFinite(a.rawday) || "29" == a.day && !isFinite(a.rawyear) || new Date(a.date.getFullYear(), isFinite(a.rawmonth) ? a.month : a.date.getMonth() + 1, 0).getDate() >= a.day) && r) && function(e, t) {
                        var i = !0;
                        {
                            var n, a;
                            t.min && (e.rawyear && (n = e.rawyear.replace(/[^0-9]/g, ""), a = t.min.year.substr(0, n.length), i = a <= n), e.year === e.rawyear && t.min.date.getTime() == t.min.date.getTime() && (i = t.min.date.getTime() <= e.date.getTime()))
                        }
                        i && t.max && t.max.date.getTime() == t.max.date.getTime() && (i = t.max.date.getTime() >= e.date.getTime());
                        return i
                    }(s, n)), t && o && i.pos !== t ? {
                        buffer: u(n.inputFormat, s, n),
                        refreshFromBuffer: {
                            start: t,
                            end: i.pos
                        }
                    } : o
                },
                onKeyDown: function(e, t, i, n) {
                    if (e.ctrlKey && e.keyCode === s.keyCode.RIGHT) {
                        for (var a, r = new Date, o = ""; a = d(n).exec(n.inputFormat);) "d" === a[0].charAt(0) ? o += f(r.getDate(), a[0].length) : "m" === a[0].charAt(0) ? o += f(r.getMonth() + 1, a[0].length) : "yyyy" === a[0] ? o += r.getFullYear().toString() : "y" === a[0].charAt(0) && (o += f(r.getYear(), a[0].length));
                        this.inputmask._valueSet(o), l(this).trigger("setvalue")
                    }
                },
                onUnMask: function(e, t, i) {
                    return u(i.outputFormat, c(e, i.inputFormat, i), i, !0)
                },
                casing: function(e, t) {
                    return 0 == t.nativeDef.indexOf("[ap]") ? e.toLowerCase() : 0 == t.nativeDef.indexOf("[AP]") ? e.toUpperCase() : e
                },
                insertMode: !1,
                shiftPositions: !1
            }
        }), s
    }) ? n.apply(t, a) : n) || (e.exports = r)
}, function(e, t, i) {
    "use strict";
    var n, a, r;
    a = [i(2)], void 0 === (r = "function" == typeof(n = function(b) {
        var x = b.dependencyLib;

        function o(e, t) {
            var i = "";
            for (var n = 0; n < e.length; n++) {
                if (b.prototype.definitions[e.charAt(n)] || t.definitions[e.charAt(n)] || t.optionalmarker.start === e.charAt(n) || t.optionalmarker.end === e.charAt(n) || t.quantifiermarker.start === e.charAt(n) || t.quantifiermarker.end === e.charAt(n) || t.groupmarker.start === e.charAt(n) || t.groupmarker.end === e.charAt(n) || t.alternatormarker === e.charAt(n)) {
                    i += "\\" + e.charAt(n)
                } else i += e.charAt(n)
            }
            return i
        }

        function e(e, t, i) {
            if (0 < t) {
                var n = x.inArray(i.radixPoint, e); - 1 === n && (e.push(i.radixPoint), n = e.length - 1);
                for (var a = 1; a <= t; a++) e[n + a] = e[n + a] || "0"
            }
            return e
        }
        return b.extendAliases({
            numeric: {
                mask: function(e) {
                    var t, i;
                    0 !== e.repeat && isNaN(e.integerDigits) && (e.integerDigits = e.repeat), e.repeat = 0, e.groupSeparator === e.radixPoint && e.digits && "0" !== e.digits && ("." === e.radixPoint ? e.groupSeparator = "," : "," === e.radixPoint ? e.groupSeparator = "." : e.groupSeparator = ""), " " === e.groupSeparator && (e.skipOptionalPartCharacter = void 0), e.autoGroup = e.autoGroup && "" !== e.groupSeparator, e.autoGroup && ("string" == typeof e.groupSize && isFinite(e.groupSize) && (e.groupSize = parseInt(e.groupSize)), isFinite(e.integerDigits) && (t = Math.floor(e.integerDigits / e.groupSize), i = e.integerDigits % e.groupSize, e.integerDigits = parseInt(e.integerDigits) + (0 == i ? t - 1 : t), e.integerDigits < 1 && (e.integerDigits = "*"))), 1 < e.placeholder.length && (e.placeholder = e.placeholder.charAt(0)), "radixFocus" === e.positionCaretOnClick && "" === e.placeholder && !1 === e.integerOptional && (e.positionCaretOnClick = "lvp"), e.definitions[";"] = e.definitions["~"], e.definitions[";"].definitionSymbol = "~", !0 === e.numericInput && (e.positionCaretOnClick = "radixFocus" === e.positionCaretOnClick ? "lvp" : e.positionCaretOnClick, e.digitsOptional = !1, isNaN(e.digits) && (e.digits = 2), e.decimalProtect = !1);
                    var n, a, r = "[+]";
                    return r += o(e.prefix, e), !0 === e.integerOptional ? r += "~{1," + e.integerDigits + "}" : r += "~{" + e.integerDigits + "}", void 0 !== e.digits && (n = e.decimalProtect ? ":" : e.radixPoint, a = e.digits.toString().split(","), isFinite(a[0]) && a[1] && isFinite(a[1]) ? r += n + ";{" + e.digits + "}" : (isNaN(e.digits) || 0 < parseInt(e.digits)) && (e.digitsOptional ? r += "[" + n + ";{1," + e.digits + "}]" : r += n + ";{" + e.digits + "}")), r += o(e.suffix, e), r += "[-]", e.greedy = !1, r
                },
                placeholder: "",
                greedy: !1,
                digits: "*",
                digitsOptional: !0,
                enforceDigitsOnBlur: !1,
                radixPoint: ".",
                positionCaretOnClick: "radixFocus",
                groupSize: 3,
                groupSeparator: "",
                autoGroup: !1,
                allowMinus: !0,
                negationSymbol: {
                    front: "-",
                    back: ""
                },
                integerDigits: "+",
                integerOptional: !0,
                prefix: "",
                suffix: "",
                rightAlign: !0,
                decimalProtect: !0,
                min: null,
                max: null,
                step: 1,
                insertMode: !0,
                autoUnmask: !1,
                unmaskAsNumber: !1,
                inputType: "text",
                inputmode: "numeric",
                preValidation: function(e, t, i, n, a, r) {
                    if ("-" === i || i === a.negationSymbol.front) return !0 === a.allowMinus && (a.isNegative = void 0 === a.isNegative || !a.isNegative, "" === e.join("") || {
                        caret: r.validPositions[t] ? t : void 0,
                        dopost: !0
                    });
                    if (!1 === n && i === a.radixPoint && void 0 !== a.digits && (isNaN(a.digits) || 0 < parseInt(a.digits))) {
                        var o = x.inArray(a.radixPoint, e);
                        if (-1 !== o && void 0 !== r.validPositions[o]) return !0 === a.numericInput ? t === o : {
                            caret: o + 1
                        }
                    }
                    return !0
                },
                postValidation: function(e, t, i, n) {
                    var a = n.suffix.split(""),
                        r = n.prefix.split("");
                    if (void 0 === i.pos && void 0 !== i.caret && !0 !== i.dopost) return i;
                    var o = void 0 !== i.caret ? i.caret : i.pos,
                        s = e.slice();
                    n.numericInput && (o = s.length - o - 1, s = s.reverse());
                    var l = s[o];
                    if (l === n.groupSeparator && (l = s[o += 1]), o === s.length - n.suffix.length - 1 && l === n.radixPoint) return i;
                    void 0 !== l && l !== n.radixPoint && l !== n.negationSymbol.front && l !== n.negationSymbol.back && (s[o] = "?", 0 < n.prefix.length && o >= (!1 === n.isNegative ? 1 : 0) && o < n.prefix.length - 1 + (!1 === n.isNegative ? 1 : 0) ? r[o - (!1 === n.isNegative ? 1 : 0)] = "?" : 0 < n.suffix.length && o >= s.length - n.suffix.length - (!1 === n.isNegative ? 1 : 0) && (a[o - (s.length - n.suffix.length - (!1 === n.isNegative ? 1 : 0))] = "?")), r = r.join(""), a = a.join("");
                    var u, f, c, p, d, m, h = s.join("").replace(r, "");
                    if (h = (h = (h = (h = h.replace(a, "")).replace(new RegExp(b.escapeRegex(n.groupSeparator), "g"), "")).replace(new RegExp("[-" + b.escapeRegex(n.negationSymbol.front) + "]", "g"), "")).replace(new RegExp(b.escapeRegex(n.negationSymbol.back) + "$"), ""), isNaN(n.placeholder) && (h = h.replace(new RegExp(b.escapeRegex(n.placeholder), "g"), "")), 1 < h.length && 1 !== h.indexOf(n.radixPoint) && ("0" === l && (h = h.replace(/^\?/g, "")), h = h.replace(/^0/g, "")), h.charAt(0) === n.radixPoint && "" !== n.radixPoint && !0 !== n.numericInput && (h = "0" + h), "" !== h) {
                        if (h = h.split(""), (!n.digitsOptional || n.enforceDigitsOnBlur && "blur" === i.event) && isFinite(n.digits)) {
                            var g = x.inArray(n.radixPoint, h),
                                v = x.inArray(n.radixPoint, s); - 1 === g && (h.push(n.radixPoint), g = h.length - 1);
                            for (var k = 1; k <= n.digits; k++) n.digitsOptional && (!n.enforceDigitsOnBlur || "blur" !== i.event) || void 0 !== h[g + k] && h[g + k] !== n.placeholder.charAt(0) ? -1 !== v && void 0 !== s[v + k] && (h[g + k] = h[g + k] || s[v + k]) : h[g + k] = i.placeholder || n.placeholder.charAt(0)
                        }!0 !== n.autoGroup || "" === n.groupSeparator || l === n.radixPoint && void 0 === i.pos && !i.dopost ? h = h.join("") : (u = h[h.length - 1] === n.radixPoint && i.c === n.radixPoint, h = b((f = h, d = "", d += "(" + (c = n).groupSeparator + "*{" + c.groupSize + "}){*}", "" === c.radixPoint || (p = f.join("").split(c.radixPoint))[1] && (d += c.radixPoint + "*{" + p[1].match(/^\d*\??\d*/)[0].length + "}"), d), {
                            numericInput: !0,
                            jitMasking: !0,
                            definitions: {
                                "*": {
                                    validator: "[0-9?]",
                                    cardinality: 1
                                }
                            }
                        }).format(h.join("")), u && (h += n.radixPoint), h.charAt(0) === n.groupSeparator && h.substr(1))
                    }
                    n.isNegative && "blur" === i.event && (n.isNegative = "0" !== h), h = r + h, h += a, n.isNegative && (h = n.negationSymbol.front + h, h += n.negationSymbol.back), h = h.split(""), void 0 !== l && (l !== n.radixPoint && l !== n.negationSymbol.front && l !== n.negationSymbol.back ? -1 < (o = x.inArray("?", h)) ? h[o] = l : o = i.caret || 0 : l !== n.radixPoint && l !== n.negationSymbol.front && l !== n.negationSymbol.back || -1 !== (m = x.inArray(l, h)) && (o = m)), n.numericInput && (o = h.length - o - 1, h = h.reverse());
                    var y = {
                        caret: void 0 !== l && void 0 === i.pos || void 0 === o ? o : o + (n.numericInput ? -1 : 1),
                        buffer: h,
                        refreshFromBuffer: i.dopost || e.join("") !== h.join("")
                    };
                    return y.refreshFromBuffer ? y : i
                },
                onBeforeWrite: function(e, t, i, n) {
                    if (e) switch (e.type) {
                        case "keydown":
                            return n.postValidation(t, i, {
                                caret: i,
                                dopost: !0
                            }, n);
                        case "blur":
                        case "checkval":
                            var a;
                            if (void 0 === (r = n).parseMinMaxOptions && (null !== r.min && (r.min = r.min.toString().replace(new RegExp(b.escapeRegex(r.groupSeparator), "g"), ""), "," === r.radixPoint && (r.min = r.min.replace(r.radixPoint, ".")), r.min = isFinite(r.min) ? parseFloat(r.min) : NaN, isNaN(r.min) && (r.min = Number.MIN_VALUE)), null !== r.max && (r.max = r.max.toString().replace(new RegExp(b.escapeRegex(r.groupSeparator), "g"), ""), "," === r.radixPoint && (r.max = r.max.replace(r.radixPoint, ".")), r.max = isFinite(r.max) ? parseFloat(r.max) : NaN, isNaN(r.max) && (r.max = Number.MAX_VALUE)), r.parseMinMaxOptions = "done"), null !== n.min || null !== n.max) {
                                if (a = n.onUnMask(t.join(""), void 0, x.extend({}, n, {
                                        unmaskAsNumber: !0
                                    })), null !== n.min && a < n.min) return n.isNegative = n.min < 0, n.postValidation(n.min.toString().replace(".", n.radixPoint).split(""), i, {
                                    caret: i,
                                    dopost: !0,
                                    placeholder: "0"
                                }, n);
                                if (null !== n.max && a > n.max) return n.isNegative = n.max < 0, n.postValidation(n.max.toString().replace(".", n.radixPoint).split(""), i, {
                                    caret: i,
                                    dopost: !0,
                                    placeholder: "0"
                                }, n)
                            }
                            return n.postValidation(t, i, {
                                caret: i,
                                placeholder: "0",
                                event: "blur"
                            }, n);
                        case "_checkval":
                            return {
                                caret: i
                            }
                    }
                    var r
                },
                regex: {
                    integerPart: function(e, t) {
                        return t ? new RegExp("[" + b.escapeRegex(e.negationSymbol.front) + "+]?") : new RegExp("[" + b.escapeRegex(e.negationSymbol.front) + "+]?\\d+")
                    },
                    integerNPart: function(e) {
                        return new RegExp("[\\d" + b.escapeRegex(e.groupSeparator) + b.escapeRegex(e.placeholder.charAt(0)) + "]+")
                    }
                },
                definitions: {
                    "~": {
                        validator: function(e, t, i, n, a, r) {
                            var o;
                            if ("k" === e || "m" === e) {
                                o = {
                                    insert: [],
                                    c: 0
                                };
                                for (var s = 0, l = "k" === e ? 2 : 5; s < l; s++) o.insert.push({
                                    pos: i + s,
                                    c: 0
                                });
                                return o.pos = i + l, o
                            }
                            if (!0 === (o = n ? new RegExp("[0-9" + b.escapeRegex(a.groupSeparator) + "]").test(e) : new RegExp("[0-9]").test(e))) {
                                if (!0 !== a.numericInput && void 0 !== t.validPositions[i] && "~" === t.validPositions[i].match.def && !r) {
                                    var u = t.buffer.join(""),
                                        f = (u = (u = u.replace(new RegExp("[-" + b.escapeRegex(a.negationSymbol.front) + "]", "g"), "")).replace(new RegExp(b.escapeRegex(a.negationSymbol.back) + "$"), "")).split(a.radixPoint);
                                    1 < f.length && (f[1] = f[1].replace(/0/g, a.placeholder.charAt(0))), "0" === f[0] && (f[0] = f[0].replace(/0/g, a.placeholder.charAt(0))), u = f[0] + a.radixPoint + f[1] || "";
                                    var c = t._buffer.join("");
                                    for (u === a.radixPoint && (u = c); null === u.match(b.escapeRegex(c) + "$");) c = c.slice(1);
                                    o = void 0 === (u = (u = u.replace(c, "")).split(""))[i] ? {
                                        pos: i,
                                        remove: i
                                    } : {
                                        pos: i
                                    }
                                }
                            } else n || e !== a.radixPoint || void 0 !== t.validPositions[i - 1] || (o = {
                                insert: {
                                    pos: i,
                                    c: 0
                                },
                                pos: i + 1
                            });
                            return o
                        },
                        cardinality: 1
                    },
                    "+": {
                        validator: function(e, t, i, n, a) {
                            return a.allowMinus && ("-" === e || e === a.negationSymbol.front)
                        },
                        cardinality: 1,
                        placeholder: ""
                    },
                    "-": {
                        validator: function(e, t, i, n, a) {
                            return a.allowMinus && e === a.negationSymbol.back
                        },
                        cardinality: 1,
                        placeholder: ""
                    },
                    ":": {
                        validator: function(e, t, i, n, a) {
                            var r = "[" + b.escapeRegex(a.radixPoint) + "]",
                                o = new RegExp(r).test(e);
                            return o && t.validPositions[i] && t.validPositions[i].match.placeholder === a.radixPoint && (o = {
                                caret: i + 1
                            }), o
                        },
                        cardinality: 1,
                        placeholder: function(e) {
                            return e.radixPoint
                        }
                    }
                },
                onUnMask: function(e, t, i) {
                    if ("" === t && !0 === i.nullable) return t;
                    var n = e.replace(i.prefix, "");
                    return n = (n = n.replace(i.suffix, "")).replace(new RegExp(b.escapeRegex(i.groupSeparator), "g"), ""), "" !== i.placeholder.charAt(0) && (n = n.replace(new RegExp(i.placeholder.charAt(0), "g"), "0")), i.unmaskAsNumber ? ("" !== i.radixPoint && -1 !== n.indexOf(i.radixPoint) && (n = n.replace(b.escapeRegex.call(this, i.radixPoint), ".")), n = (n = n.replace(new RegExp("^" + b.escapeRegex(i.negationSymbol.front)), "-")).replace(new RegExp(b.escapeRegex(i.negationSymbol.back) + "$"), ""), Number(n)) : n
                },
                isComplete: function(e, t) {
                    var i = (t.numericInput ? e.slice().reverse() : e).join("");
                    return i = (i = (i = (i = (i = i.replace(new RegExp("^" + b.escapeRegex(t.negationSymbol.front)), "-")).replace(new RegExp(b.escapeRegex(t.negationSymbol.back) + "$"), "")).replace(t.prefix, "")).replace(t.suffix, "")).replace(new RegExp(b.escapeRegex(t.groupSeparator) + "([0-9]{3})", "g"), "$1"), "," === t.radixPoint && (i = i.replace(b.escapeRegex(t.radixPoint), ".")), isFinite(i)
                },
                onBeforeMask: function(e, t) {
                    t.isNegative = void 0;
                    var i = t.radixPoint || ",";
                    "number" != typeof e && "number" !== t.inputType || "" === i || (e = e.toString().replace(".", i));
                    var n = e.split(i),
                        a = n[0].replace(/[^\-0-9]/g, ""),
                        r = 1 < n.length ? n[1].replace(/[^0-9]/g, "") : "";
                    e = a + ("" !== r ? i + r : r);
                    var o, s = 0;
                    return "" !== i && (s = r.length, "" !== r && (o = Math.pow(10, s || 1), isFinite(t.digits) && (s = parseInt(t.digits), o = Math.pow(10, s)), e = e.replace(b.escapeRegex(i), "."), isFinite(e) && (e = Math.round(parseFloat(e) * o) / o), e = e.toString().replace(".", i))), 0 === t.digits && -1 !== e.indexOf(b.escapeRegex(i)) && (e = e.substring(0, e.indexOf(b.escapeRegex(i)))),
                        function(e, t, i) {
                            if (0 < t) {
                                var n = x.inArray(i.radixPoint, e); - 1 === n && (e.push(i.radixPoint), n = e.length - 1);
                                for (var a = 1; a <= t; a++) e[n + a] = e[n + a] || "0"
                            }
                            return e
                        }(e.toString().split(""), s, t).join("")
                },
                onKeyDown: function(e, t, i, n) {
                    var a = x(this);
                    if (e.ctrlKey) switch (e.keyCode) {
                        case b.keyCode.UP:
                            a.val(parseFloat(this.inputmask.unmaskedvalue()) + parseInt(n.step)), a.trigger("setvalue");
                            break;
                        case b.keyCode.DOWN:
                            a.val(parseFloat(this.inputmask.unmaskedvalue()) - parseInt(n.step)), a.trigger("setvalue")
                    }
                }
            },
            currency: {
                prefix: "$ ",
                groupSeparator: ",",
                alias: "numeric",
                placeholder: "0",
                autoGroup: !0,
                digits: 2,
                digitsOptional: !1,
                clearMaskOnLostFocus: !1
            },
            decimal: {
                alias: "numeric"
            },
            integer: {
                alias: "numeric",
                digits: 0,
                radixPoint: ""
            },
            percentage: {
                alias: "numeric",
                digits: 2,
                digitsOptional: !0,
                radixPoint: ".",
                placeholder: "0",
                autoGroup: !1,
                min: 0,
                max: 100,
                suffix: " %",
                allowMinus: !1
            }
        }), b
    }) ? n.apply(t, a) : n) || (e.exports = r)
}, function(e, t, i) {
    "use strict";
    var n, a, r, o = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(e) {
        return typeof e
    } : function(e) {
        return e && "function" == typeof Symbol && e.constructor === Symbol && e !== Symbol.prototype ? "symbol" : typeof e
    };
    a = [i(4), i(2)], void 0 === (r = "function" == typeof(n = function(a, r) {
        if (a.fn.inputmask === undefined) {
            a.fn.inputmask = function(e, t) {
                var i, n = this[0];
                if (t === undefined) t = {};
                if (typeof e === "string") {
                    switch (e) {
                        case "unmaskedvalue":
                            return n && n.inputmask ? n.inputmask.unmaskedvalue() : a(n).val();
                        case "remove":
                            return this.each(function() {
                                if (this.inputmask) this.inputmask.remove()
                            });
                        case "getemptymask":
                            return n && n.inputmask ? n.inputmask.getemptymask() : "";
                        case "hasMaskedValue":
                            return n && n.inputmask ? n.inputmask.hasMaskedValue() : false;
                        case "isComplete":
                            return n && n.inputmask ? n.inputmask.isComplete() : true;
                        case "getmetadata":
                            return n && n.inputmask ? n.inputmask.getmetadata() : undefined;
                        case "setvalue":
                            r.setValue(n, t);
                            break;
                        case "option":
                            if (typeof t === "string") {
                                if (n && n.inputmask !== undefined) {
                                    return n.inputmask.option(t)
                                }
                            } else {
                                return this.each(function() {
                                    if (this.inputmask !== undefined) {
                                        return this.inputmask.option(t)
                                    }
                                })
                            }
                            break;
                        default:
                            t.alias = e;
                            i = new r(t);
                            return this.each(function() {
                                i.mask(this)
                            })
                    }
                } else if (Array.isArray(e)) {
                    t.alias = e;
                    i = new r(t);
                    return this.each(function() {
                        i.mask(this)
                    })
                } else if ((typeof e === "undefined" ? "undefined" : o(e)) == "object") {
                    i = new r(e);
                    if (e.mask === undefined && e.alias === undefined) {
                        return this.each(function() {
                            if (this.inputmask !== undefined) {
                                return this.inputmask.option(e)
                            } else i.mask(this)
                        })
                    } else {
                        return this.each(function() {
                            i.mask(this)
                        })
                    }
                } else if (e === undefined) {
                    return this.each(function() {
                        i = new r(t);
                        i.mask(this)
                    })
                }
            }
        }
        return a.fn.inputmask
    }) ? n.apply(t, a) : n) || (e.exports = r)
}]);